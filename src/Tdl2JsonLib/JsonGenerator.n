using DotNet;

using JsonDal;

using Microsoft.Cci.MetadataReader.ObjectModelImplementation;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Utility.Pair;

using Newtonsoft.Json;

using Nitra;
using Nitra.BackEnd.Cci;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using Microsoft.Cci;

using QuickType;
using Utils;

using System;
using System.Globalization;
using System.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;

using Tdl;
using Tdl2Json.ExceptionHelper;

// Сгенерированно с помощью: https://app.quicktype.io/
namespace Tdl2Json
{
  public delegate TransfomationFunc(context : TransformationContext) : void;
  public delegate MessageHandler(text : string, importance : MessageImportance) : void;

  public enum MessageImportance
  {
    | Low
    | High
  }

  public module JsonGenerator
  {
    public ParameterDefaultValue = "C3EEBA2A-D830-4947-83B2-045529DCB327";
    
    static JsonVersion : int = 7;
    public IsExperimental = ThisAssembly.BranchName != "master";

    public event OnMessage : MessageHandler;

    public Generate(
      [NotNullOrEmpty] workingDirectory         : string,
      [NotNull]        sourceFiles              : array[string],
      [NotNull]        references               : array[string],
                       deploymentScriptHeader   : string,
               mutable deploymentToolPath       : string,
                       isMethodTypingEnabled    : bool,
                       output                   : Lazy[TextWriter],
                       transformatorOutput      : string,
                       transformatorOpt         : TransfomationFunc,
                       isTestMode               : bool,
                       booleanMarshalMode       : BooleanMarshalMode,
                       jsonSchemaType           : string,
                       diffFile                 : string,
                       repositoryRoot           : string
      ) : TransformationContext
    {
      BooleanLiterals.Setup(booleanMarshalMode);

      def mode =
        match (isTestMode)
        {
          | true                             => CompilerMode.Test
          | _  when transformatorOpt != null => CompilerMode.Transform
          | _                                => CompilerMode.Compile
        };
      def absolutePaths = sourceFiles.Map(f => if(Path.IsPathRooted(f)) f else Path.Combine(workingDirectory, f));

      def CheckFilesExists(files, messageformatter : string -> string)
      {
        def notFoundFiles = files.Where(f => !File.Exists(f)).ToList();
        when (notFoundFiles.Any())
        {
          def messages = notFoundFiles.Select(messageformatter).ToArray();
          throw ConfigurationException(string.Join("\r\n", messages));
        }
      }

      CheckFilesExists(absolutePaths, m => $"File not found: $m");

      def context = Compile(workingDirectory, absolutePaths, references, isMethodTypingEnabled, mode, transformatorOutput);
      unless (context.Messages.HasErrors)
      {
        if (mode == CompilerMode.Transform)
          transformatorOpt(context);
        else
        {
          when (string.IsNullOrEmpty(deploymentToolPath))
            deploymentToolPath = <#.\KL.Autotests.Deployer.exe#>;

          GenerateJson(context.RootNamespace, context.InitialDeployment, context.FinalDeployment, context.ExternalSymbols, output,
            deploymentScriptHeader, deploymentToolPath, jsonSchemaType, diffFile, repositoryRoot);
        }
      }

      context
    }

    private static StandardLibraries : array[LibReference] = array[
      FullNameLibReference("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"),
      FullNameLibReference("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"),
      FullNameLibReference("System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
    ];

    private Compile(directory : string, files : array[string], refs : array[string], isMethodTypingEnabled : bool, mode : CompilerMode,
      transformatorOutput : string) : TransformationContext
    {
      TdlTypingSettings.IsMethodTypingEnabled = isMethodTypingEnabled;
      
      def commentBag     = if (mode == CompilerMode.Compile) null else CommentBag();
      def solution       = FsSolution();
      def project        = FsProject(solution, 
                                     directory, 
                                     files.Map(FsFileWithId(_, TdlLang.Instance, commentBag)),
                                     StandardLibraries.Concat(refs.Select(FileLibReference)).ToArray());
      def stopwatch      = Stopwatch.StartNew();
      def projectSupport = ProjectSupport(testMode=true);
      ReportMessage("Loading types from referenced assemblies...");
      def data           = projectSupport.RefreshReferences(CancellationToken.None, project);
      ReportElapsedTime(stopwatch);

      ReportMessage("Parsing TDLs...");
      project.Data       = data;
      def files          = project.Files.Select(_.GetEvalPropertiesData()).ToImmutableArray();
      ReportElapsedTime(stopwatch);

      ReportMessage("Semantic analysis...");
      projectSupport.RefreshProject(CancellationToken.None, files, data);
      ReportElapsedTime(stopwatch);

      def messages = CompilerMessageBag(project.CompilerMessages :> CompilerMessageList);

      foreach (file when file.HasCompilerMessage in files)
        _ = messages.AddRange(file.GetCompilerMessage());

      foreach (file in project.Files)
        _ = messages.AddRange(file.GetCompilerMessages());

      def tdlProjectData = data :> TdlProjectData;
      def evalContext    = tdlProjectData.Context :> TdlDependentPropertyEvalContext;
      TransformationContext(tdlProjectData.RootNamespace, commentBag, messages, evalContext.InitialDeployment, evalContext.FinalDeployment,
        tdlProjectData.ExternalSymbolTable, transformatorOutput)
    }

    internal ReportMessage(msg : string, importance : MessageImportance = MessageImportance.High) : void
    {
      OnMessage?.Invoke(msg, importance);
    }

    private ReportElapsedTime(stopwatch : Stopwatch) : void
    {
      ReportMessage($"Elapsed time: $(stopwatch.Elapsed)");
      stopwatch.Restart();
    }

    private GenerateJson(root : NamespaceSymbol, initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol, externalSymbols : TableScope,
      output : Lazy[TextWriter], deploymentScriptHeader : string, deploymentToolPath : string, mutable jsonSchemaType : string,
      diffFile : string, repositoryRoot : string) : void
    {
      def stopwatch = Stopwatch.StartNew();
      JsonGenerator.ReportMessage("Generating JSON...");

      when (string.IsNullOrEmpty(jsonSchemaType))
        jsonSchemaType = if (IsExperimental) "dev" else "prod";

      def compiler    = DeploymentCompiler(deploymentScriptHeader, deploymentToolPath);
      def symbols     = root.MemberTable.GetAllSymbols().ToList();

      mutable scenarioTrigger;
      when (!string.IsNullOrEmpty(diffFile) && !string.IsNullOrEmpty(repositoryRoot))
      {
        scenarioTrigger = ScenarioTriggerProcessor(repositoryRoot);
        foreach (scenario is ScenarioSymbol in symbols)
          scenarioTrigger.AddScenario(scenario);
        using (reader = StreamReader(diffFile))
          scenarioTrigger.LoadDiff(reader);
      }

      def platforms   = SortedDictionary();
      def products    = SortedDictionary();
      def entities    = SortedDictionary();
      def suites      = SortedDictionary();
      def suiteGroups = SortedDictionary();
      def scenarios   = SortedDictionary();

      foreach (s is PlatformSymbol in symbols)
        platforms.Add(s.Name, GeneratePlatform(s));

      def platformNameSet = HashSet(platforms.Select(p => p.Key), StringComparer.InvariantCultureIgnoreCase);

      foreach (symbol in symbols)
      {
        | ProductSymbol         as s => products .Add(s.Name, GenerateProduct(s, platformNameSet))
        | EntitySymbol          as s => entities .Add(s.Name, GenerateEntity(s))
        | Suite.DefSymbol       as s => suites   .Add(s.Name, GenerateSuite(s, scenarioTrigger))
        | Suite.GeneratorSymbol as s => GenerateSuiteGenerator(s, suites, suiteGroups, scenarioTrigger)
        | Suite.ListSymbol      as s => GenerateSuiteGroup(s, suiteGroups)
        | ScenarioSymbol        as s when IsScenarioTriggered(s, scenarioTrigger) =>
          GenerateScenario(s, initialDeployment, finalDeployment, compiler, scenarioTrigger, scenarios)

        | _ => ()
      }

      def defaultValues = SortedDictionary();
      foreach (f is FieldSymbol in externalSymbols.GetAllSymbols())
      {
        when (f.Value is VSome(v))
        {
          def value = v.ToObject();
          defaultValues.Add(f.Name, value);
        }
      }

      def config = Root() <-
      {
        Version       = JsonVersion;
        Schema        = $<#http://auto-reports.avp.ru/starter-schema/v$JsonVersion/$jsonSchemaType/schema.json#>;
        Deployments   = compiler.GetResult();
        Products      = products;
        Platforms     = platforms;
        Suites        = suites;
        TestScenarios = scenarios;
        SuiteGroups   = if (suiteGroups.Count == 0) null else suiteGroups;
        TestEntities  = entities;
        DefaultValues = if (defaultValues.Count == 0) null else defaultValues;
      };

      def settings = ConverterSettings.Settings <- Formatting = Formatting.Indented;
      def serializer = JsonSerializer.Create(settings);
      serializer.Serialize(output.Value, config);
      output.Value.Flush();

      ReportElapsedTime(stopwatch);
    }

    private GeneratePlatform(platformSymbol : PlatformSymbol) : PlatformValue
    {
      | Platform.DefSymbol        => PlatformValue() <- { Platform    = Platform() }
      | Platform.SetSymbol as Set => PlatformValue() <- { StringArray = Set.Platforms.Select(_.Name).ToArray(); }
      | _                         => ThrowNotSupportedSymbol(platformSymbol)
    }
      
    private CollectDefs(defs : Seq[Def], variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : Dictionary[string, object]
    {
      def result = Dictionary();
      foreach(@def in defs)
      {
        def name = @def.Symbol.Name;
        result.Add(name, @def.Expr.ToObject(variables=variables));
      }
      result
    }

    private GenerateProduct(productSymbol : ProductSymbol, platformNameSet : HashSet[string]) : ProductValue
    {
      match (productSymbol)
      {
        | Product.DefSymbol as Def =>
          def isPlatforms(x : Def) : bool
          {
            x.Symbol.Name.Equals("Platforms", StringComparison.CurrentCultureIgnoreCase)
          }
          def parameters = CollectDefs(Def.Defs.Where(x => !isPlatforms(x)));
          def useAsFixedParameter(name : string) : string
          {
            mutable value;
            if (parameters.TryGetValue(name, out value))
            {
              _ = parameters.Remove(name);
              value :> string
            }
            else
              null
          }
          def name = useAsFixedParameter("Name");
          parameters.Add("Name", name);
          def expr = Def.Defs.FirstOrDefault(isPlatforms);
          def platforms =
            if (expr : object == null)
              null
            else
            {
              def platforms = expr.Expr.GetExprList().Select(_.ToString()).ToArray();
              if (platformNameSet.SetEquals(platforms))
                null // ignore if all platforms included
              else
                platforms.OrderBy(x => x).ToArray()
            };
          ProductValue() <- 
          {
            Product = Product() <- { 
              Name              = name;
              BranchName        = useAsFixedParameter("ReleaseName") ?? useAsFixedParameter("BranchName"); // 
              Version           = useAsFixedParameter("Version");
              DumpServerProduct = useAsFixedParameter("DumpServerProduct");
              Parameters        = parameters;
              Platforms         = platforms;
            }
          }
        | Product.SetSymbol as Set => ProductValue() <- { StringArray = Set.AllProducts.Select(p => p.Name).ToArray(); }
        | _ => ThrowNotSupportedSymbol(productSymbol)
      }
    }

    private GetAssemblyAndMethodName(typeSymbolOpt : DeclarationSymbol, [NotNull] methodSymbol : Member.MethodSymbol) : string * string
    {
      def decl         = methodSymbol.GetDeclarationsOfType.[ExternalMethodDeclaration]();
      def method       = decl.First().Method;
      def typeSymbol   = typeSymbolOpt :> SymbolBase;
      def type         = if (typeSymbol == null) method.ContainingType :> ITypeDefinition
                         else typeSymbol.GetDeclarationsOfType.[ExternalTopTypeDeclaration.[TopClassSymbol]]().First().Type;
      def unit         = TypeHelper.GetDefiningUnit(type);
      def assemblyName = unit.Name.Value + ".dll";
      def methodName   = type + "." + method.Name.Value;

      (assemblyName, methodName)
    }

    private SubstituteVariables(froms : ImmutableArray[Code.From], index : int = 0) : Seq[Dictionary[TypedDeclarationSymbol, Tdl.Expr]]
    {
      if (index < froms.Length)
      {
        def from = froms[index];
        foreach (dictionary in SubstituteVariables(froms, index + 1))
        {
          foreach (expr in from.Elems.GetExprList())
          {
            | Expr.Tuple as t =>
              foreach (var in from.Vars with i)
                dictionary[var] = t.Elems[i];
              yield dictionary;

            | _ =>
              assert2(from.Vars.Length == 1);
              def var = from.Vars[0];
              dictionary[var] = expr;
              yield dictionary;
          }
        }
      }
      else
        yield Dictionary();
    }
    
    TryResolveVar[T](dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr], varOrSymbol : TypedDeclarationSymbol) :  T
      where T: DeclarationSymbol
    {
      mutable result;
      if (dic.TryGetValue(varOrSymbol, out result))
      {
        if (result is Tdl.Expr.Reference as r)
          r.Symbol :> T
        else if (result is Tdl.Expr.MemberAccess as m)
          m.Symbol :> T
        else
          result.GetValue() :> T
      }
      else
        varOrSymbol :> T
    }
    
    GetFixedString(g : Tdl.Scenario.GeneratorSymbol, name : string) : string
    {
      g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
    }

    private GenerateTestGroup(g : Tdl.Scenario.GeneratorSymbol, uniqueId : Guid, dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr],
      initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol, compiler : DeploymentCompiler) : TestGroup
    {
      def getString(name : string) : string
      {
        def getValue(expr : Tdl.Expr) : string
        {
          | String as s => s.Value
          | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
          | Reference(Symbol=FieldSymbol(DeclaredIn=ExternalSymbol) as fld) => $"#($(fld.Name))"
          | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        g.Defs.Find(d => d.Symbol.Name == name).Map(d => getValue(d.Expr)).WithDefault(null);
      }
      def getBool(name : string) : bool?
      {
        def getValue(expr : Tdl.Expr) : bool?
        {
              | Tdl.Expr.True  => Nullable(true)
              | Tdl.Expr.False => Nullable(false)
              | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
              | _              => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(getValue).WithDefault(null);
      }
      def getLong(name : string) : long?
      {
          def getValue(expr : Tdl.Expr) : long?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(getValue).WithDefault(null);
      }
      def getInt(name : string) : int?
      {
          def getValue(expr : Tdl.Expr) : int?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(getValue).WithDefault(null);
      }
      def deployment = TryResolveVar(dic, g.Deployment) : DeploymentSymbol;
      def method     = TryResolveVar(dic, g.Method)     : Member.MethodSymbol;
      def platform   = TryResolveVar(dic, g.Platform)   : PlatformSymbol;
      def product    = TryResolveVar(dic, g.Product)    : ProductSymbol;
      def getTestMethod() : TestMethod
      {
        def (assemblyName, methodName) = GetAssemblyAndMethodName(null, method);
        TestMethodQualifier() <- 
        {
          AssemblyName = assemblyName;
          MethodName   = methodName;
        }
      }
      def testGroup =
        TestGroup() <- 
        {
          Deployments             = GetTestGroupDeployments(initialDeployment, finalDeployment, deployment, compiler);
          Environments            = array[EnvironmentElement() <- { Platforms= array[platform.Name]; Products=array[product.Name]; }];
          TestMethod              = getTestMethod();
          Area                    = getString("Area");
          ExternalAutotestId      = getInt   ("ExternalAutotestId");
          LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
          NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
          RequireInternet         = getBool  ("RequireInternet");
          RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
          RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
          Responsible             = getString("Responsible");
          RevertAgentAfter        = getBool  ("RevertAgentAfter") ?? true;
          RevertAgentBefore       = getBool  ("RevertAgentBefore");
          TfsId                   = getLong  ("TfsId");
          Timeout                 = getString("Timeout");
          UniqueId                = uniqueId;
          ProductGroupName        = getString("ProductGroupName");
          FilterExpression        = GenerateScenarioFilter(g.Filter :> DotNet.ExprBase, dic);
        };

      testGroup
    }

    private GenerateScenario(scenarioSymbol : ScenarioSymbol, initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol,
      compiler : DeploymentCompiler, scenarioTrigger : ScenarioTriggerProcessor, scenarios : IDictionary[string, TestCase]) : void
    {
      def addTestCase(name, testGroup)
      {
        scenarios.Add(name, TestCase() <- { TestGroup = testGroup; });
      }

      match (scenarioSymbol)
      {
        | Tdl.Scenario.DefSymbol as r =>
          def parallelSetOpt = if (r.IsParallelSetOptEvaluated) r.ParallelSetOpt else null;
          def barriersCount  = if (parallelSetOpt == null) Dictionary() 
                                else parallelSetOpt.BarriersCount.ToDictionary();
          def getString(name : string) : string
          {
            r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
          }
          def getGuid(name : string) : Guid?
          {
            def str = r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
            if (string.IsNullOrWhiteSpace(str))
              null
            else
              Guid.Parse(str)
          }
          def getBool(name : string) : bool?
          {
            r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr)
              .Map(fun(expr)
                {
                  | Tdl.Expr.True  => Nullable(true)
                  | Tdl.Expr.False => Nullable(false)
                  | _              => throw NotSupportedException()
                })
              .WithDefault(null);
          }
          def getLong(name : string) : long?
          {
              r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => Nullable((expr :> Tdl.Expr.Integer).Value)).WithDefault(null);
          }
          def getInt(name : string) : int?
          {
              r.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => Nullable((expr :> Tdl.Expr.Integer).Value)).WithDefault(null);
          }
          def artifactsCollectionTimeout = getString("ArtifactsCollectionTimeout");
          def getTestMethod() : TestMethod
          {
            def makeMethodAction(method : ScenarioAction.Method) : TestMethodQualifier
            {
              def (assemblyName, methodName) = GetAssemblyAndMethodName(method.TypeSymbol, method.MethodSymbol);
              TestMethodQualifier() <- 
              {
                AssemblyName               = assemblyName;
                MethodName                 = methodName;
                MaxRebootsCount            = method.MaxRebootsCountOpt.ToNullable();
                ContinueOnError            = method.ContinueOnErrorOpt.ToNullable();
                ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                LocalTestBinariesFolder    = if (method.BinariesFolderOpt.HasValue) method.BinariesFolderOpt.Value else null;
              }
            }

            when (r.Actions.Length == 1)
            when (r.Actions[0] is ScenarioAction.Method as method)
              return makeMethodAction(method);

            def makeScriptAction(c : ScenarioAction.Script) : UnixScriptRunner
            {
                def testScriptArgs = string.Join(" ", c.Arguments.Select(a => a.Value.ToLiteral()));
                def env = c.Defs.Select(d => (d.Symbol.Name, d.Expr.ToObject())).ToDictionary();
                UnixScriptRunner() <-
                {
                  TestScriptName             = c.Name.Value;
                  TestScriptArgs             = testScriptArgs;
                  Environment                = env;
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ToNullable();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeGTestAction(c : ScenarioAction.GTest) : GTestProgram
            {
                def testScriptArgs = c.Arguments.MapToArray(a => a.Value);
                GTestProgram() <-
                {
                  ProgramName                = c.Name.Value;
                  Arguments                  = testScriptArgs;
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ToNullable();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeXCodeAction(c : ScenarioAction.XCode) : XCode
            {
                XCode() <-
                {
                  XCodeTestContainer         = c.Container.Value;
                  XcodePath                  = c.XcodePath .Value;
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ToNullable();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeAndroidJavaAction(c : ScenarioAction.Apk) : AndroidJava
            {
                AndroidJava() <-
                {
                  AndroidTestContainer       = c.Name.Value;
                  TestFilter                 = c.FilterOpt.ValueOrDefault;
                  TestRunnerPath             = c.RunnerPath.ValueOrDefault;
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ToNullable();
                }
            }
            def makeConfigAction(c : ScenarioAction.Config) : TestBot
            {
              TestBot() <-
              {
                TestConfigName             = c.path.Value;
                MaxRebootsCount            = c.MaxRebootsCountOpt.ToNullable();
                ArtifactsCollectionTimeout = artifactsCollectionTimeout;
              }
            }
            def makeAction(action : ScenarioAction) : TestSequenceItem
            {
              | Reboot             => RebootTestStep() <- { ForceReboot = RebootTestStep.Data() }
              | Method        as m => makeMethodAction(m)
              | WaitForReboot as x =>                   
                WaitForRebootTestStep() <- 
                {
                  WaitForReboot = 
                    WaitForRebootTestStep.Data() <-
                    {
                      RebootTimeout = if (string.IsNullOrEmpty(x.TimeSpan)) "00:05:00" else x.TimeSpan
                    };
                }
              | Barrier as barrier =>
                def b = barrier.barrier;
                WaitForBarrierTestStep() <-
                {
                  WaitForBarrier = 
                    WaitForBarrierTestStep.Data() <- 
                    {
                      Id      = b.Guid;
                      Timeout = TimeSpan.Parse(b.Timeout.Value);
                      Count   = barriersCount.GetValue(b);
                    }
                }
              | Script as s        => makeScriptAction(s)
              | Config as c        => makeConfigAction(c)
              | GTest  as g        => makeGTestAction(g)
              | XCode as x         => makeXCodeAction(x)
              | Apk as a           => makeAndroidJavaAction(a)
              | Login as login     => LoginTestStep() <- { Login = LoginTestStep.Data() <- { User = login.User.Value; Password = login.Password.Value } }
              | Logoff             => LogoffTestStep() <- { Logoff = LogoffTestStep.Data() }
              | LockWorkstation    => LockWorkstationTestStep() <- { LockWorkstation = LockWorkstationTestStep.Data() }
              | _                  => assert(false, "Unsupported ScenarioAction: " + action)
            }

            def tryGetSingleElem[T]() : ValueOption[T]
            {
              if (r.Actions.Length == 1 && r.Actions[0] is T) VSome(r.Actions[0] :> T) else VNone() 
            }
                
            if (tryGetSingleElem() is VSome(action))
              makeConfigAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeScriptAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeGTestAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeXCodeAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeAndroidJavaAction(action)
            else
              TestMethodSequence() <-
              {
                TestSequence               = r.Actions.Select(makeAction).ToArray();
                ArtifactsCollectionTimeout = artifactsCollectionTimeout;
              }
          }

          addTestCase(scenarioSymbol.Name, TestGroup() <- 
          {
              Deployments             = GetTestGroupDeployments(initialDeployment, finalDeployment, r.Deployment, compiler);
              Environments            = r.Environments.MapToArray(env => EnvironmentElement() <- { Platforms= array[env.Platform.Name]; Products=array[env.Product.Name]; });
              TestMethod              = getTestMethod();
              Area                    = getString("Area");
              LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
              ExternalAutotestId      = getInt   ("ExternalAutotestId");
              NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
              RequireInternet         = getBool  ("RequireInternet");
              RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
              RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
              Responsible             = getString("Responsible");
              RevertAgentAfter        = getBool  ("RevertAgentAfter");
              RevertAgentBefore       = getBool  ("RevertAgentBefore");
              TfsId                   = getLong  ("TfsId");
              Timeout                 = getString("Timeout");
              UniqueId                = getGuid("UniqueId");
              ProductGroupName        = getString("ProductGroupName");
              FilterExpression        = GenerateScenarioFilter(r.Filter :> DotNet.ExprBase, ImmutableDictionary.Empty);
              MultiMachineId          = if (parallelSetOpt == null) null else parallelSetOpt.MultiMachineId;
          })

        | Tdl.Scenario.SetSymbol as s =>
          addTestCase(scenarioSymbol.Name, TestGroup() <- { TestScenarios = GetScenarioList(s.Scenarios, scenarioTrigger) });

        | Tdl.Scenario.GeneratorSymbol as g =>
          mutable counter : uint = 0;
          def incGuid(guid : Guid) : Guid
          {
            def bytes1   = guid.ToByteArray();
            def version  = BitConverter.ToUInt32(bytes1, 0) + counter;
            def bytes2   = BitConverter.GetBytes(version);
            bytes1[0] = bytes2[0];
            bytes1[1] = bytes2[1];
            bytes1[2] = bytes2[2];
            bytes1[3] = bytes2[3];
            Guid(bytes1)
          }
          mutable uniqueId = Guid.Parse(GetFixedString(g, "UniqueId"));
          def names = List();
          foreach (dic in SubstituteVariables(g.Froms, 0))
          {
            counter++;
            def name = scenarioSymbol.Name + "-" + counter;
            names.Add(name);
            addTestCase(name, GenerateTestGroup(g, uniqueId, dic, initialDeployment, finalDeployment, compiler));
            uniqueId = incGuid(uniqueId);
          }
          addTestCase(scenarioSymbol.Name, TestGroup() <- { TestScenarios = names.ToArray() });

        | _ => _ = ThrowNotSupportedSymbol(scenarioSymbol)
      }
    }

    private GetTestGroupDeployments(initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol, scenarioDeployment : DeploymentSymbol,
      compiler : DeploymentCompiler) : array[TestGroupDeployment]
    {
      mutable deployments = if (finalDeployment == null) [] else [finalDeployment];

      when (!NList.Contains(deployments, scenarioDeployment))
        deployments ::= scenarioDeployment;

      when (initialDeployment != null && !NList.Contains(deployments, initialDeployment))
        deployments ::= initialDeployment;

      def result = compiler.Compile(deployments);
      compiler.GetCompositeDeployment(scenarioDeployment.Name, result)
    }

    private GenerateEntity(symbol : EntitySymbol) : TestEntity
    {
      def parameters = CollectDefs(symbol.Defs);
      TestEntity() <-
      {
        BranchName = parameters["BranchName"].ToString();
        Name       = parameters["Name"      ].ToString();
        Type       = parameters["Type"      ].ToString();
        Version    = parameters["Version"   ].ToString();
      }
    }

    private GenerateScenarioFilter() : string
    {
      null
    }
    
    private GenerateScenarioFilter(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      def result = GenerateScenarioFilterImpl(expr, dic);
      result
    }

    private GenerateTdlExpr(expr : Tdl.Expr, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | Error                         => GenerateScenarioFilter()
        | String(null)                  => "null"
        | String(s)                     => $<#@"$(s.Replace("\"", "\"\""))"#>
        | True                          => "true"
        | False                         => "false"
        | Real(num)                     => num.ToString(CultureInfo.InvariantCulture)
        | Integer(num)                  => num.ToString(CultureInfo.InvariantCulture)
        | Reference(symbol)             => GenerateBySymbol(symbol, dic)
        | MemberAccess(expr, member, _) => GenerateTdlExpr(expr, dic) + "." + member.InitialName
        | Tuple(items, _) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#(..$args)#>

        | List(items, type) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#new $(type.FullName)[] { ..$args }#>
      }
    }

    private GenerateDefaultValue(value : DotNet.DefaultValue) : string
    {
      | Null                  => "null"
      | String(null)          => "null"
      | String(s)             => $<#@"$(s.Replace("\"", "\"\""))"#>
      | Bool(true)            => "true"
      | Bool(false)           => "false"
      | Number(num, true, _)  => num.ToString(CultureInfo.InvariantCulture)
      | Number(num, false, _) => unchecked(num :> long).ToString(CultureInfo.InvariantCulture)
      | Decimal(num)          => num.ToString(CultureInfo.InvariantCulture)
      | Double(num)           => num.ToString(CultureInfo.InvariantCulture)
      | Single(num)           => num.ToString(CultureInfo.InvariantCulture)
      | t                     => throw NotSupportedException($"$(t.GetType().Name) is not supported in scenario parameters")
    }

    private GenerateBySymbol(symbol : DeclarationSymbol, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      mutable tdlExpr;
      match (symbol)
      {
        | FieldSymbol as fld =>
          match (fld.DeclaredIn)
          {
            | ExternalSymbol =>
              def type = fld.Type.FullName;
              def name = fld.Name;
              $<#(($type)externals["$name"])#>
  
            | _ => GenerateScenarioFilter()
          }
  
        | FormalParameterSymbol as p => 
          def type =
            match (p.Type)
            {
              | SuiteTypeSymbol => "TestSuite"
              | _ => p.Type.FullName
            };

          def name = p.Name; 
          def getValue =
            match (type)
            {
              | "System.Boolean" | "bool" => $<#System.Convert.ToBoolean(globals["$name"])#>
              | _                         => $<#($type)globals["$name"]#>
            };

          if (p.HasDefault())
          {
            def defaultValue = GenerateDefaultValue(p.Default);
            $<#(globals.ContainsKey("$name") ? $getValue : $defaultValue)#>
          }
          else
            $<#($getValue)#>
  
        | Member.MethodSymbol as m => m.Name
        | PlatformSymbol as p => $<#config.Platforms["$(p.Name)"]#>
        | ProductSymbol  as p => $<#config.Products["$(p.Name)"]#>
        | TypedDeclarationSymbol as s when dic.TryGetValue(s, out tdlExpr) => GenerateTdlExpr(tdlExpr, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    public static ToFullNameString(symbol : TypeSymbol) : string
    {
      | DotNet.TopConstructedTypeSymbol as s =>
        def fullName = AstUtils.MakeFullName(s.TypeInfo.DeclaredInOpt, s.TypeInfo.Name, s.Args);
        fullName
        
      | _ => GenerateScenarioFilter()
    }
    
    private GenerateScenarioFilterImpl(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | null => null
        | Expr.Is as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) is $(e.TypeNameType))#>
        | Expr.As as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) as $(e.Type))#>
        | DotNet.IntegerLiteral
        | DotNet.RealLiteral
        | DotNet.Expr.BooleanLiteral
        | DotNet.Expr.Char
        | DotNet.Expr.String => expr.ToString().Trim()
        | Expr.Invocation as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))(..$args)#>;

        | Expr.IndexerAccess as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))[..$args]#>;
        
        | Expr.Parenthesized   as e => GenerateScenarioFilterImpl(e.Expression, dic)
        | Expr.PostDecrement (Expr1=e) with op = "++"
        | Expr.PostIncrement (Expr1=e) with op = "--"
          => $<#$(GenerateScenarioFilterImpl(e, dic))$op#>

        | Expr.PreIncrement    (Expr1=e) with op = "++"
        | Expr.PreDecrement    (Expr1=e) with op = "--"
        | Expr.BitwiseNegation (Expr1=e) with op = "~"
        | Expr.LogicalNegation (Expr1=e) with op = "!"
        | Expr.Negation        (Expr1=e) with op = "-"
          => $<#$op$(GenerateScenarioFilterImpl(e, dic))#>
        
        | Expr.TypeOf as e => $<#typeof($(e.Type))#>
        | Expr.GreaterThanOrEqual(Expr1=e1, Expr2=e2)  with op = ">="
        | Expr.LessThanOrEqual   (Expr1=e1, Expr2=e2)  with op = "<=" 
        | Expr.Less              (Expr1=e1, Expr2=e2)  with op =  "<"
        | Expr.Greater           (Expr1=e1, Expr2=e2)  with op =  ">"
        | Expr.ConditionalAnd    (Expr1=e1, Expr2=e2)  with op = "&&"
        | Expr.ConditionalOr     (Expr1=e1, Expr2=e2)  with op = "||"
        | Expr.Equal             (Expr1=e1, Expr2=e2)  with op = "=="
        | Expr.NotEqual          (Expr1=e1, Expr2=e2)  with op = "!="
        | Expr.NullCoalescing    (Expr1=e1, Expr2=e2)  with op = "??"
        | Expr.LogicalOr         (Expr1=e1, Expr2=e2)  with op = "|"
        | Expr.LogicalAnd        (Expr1=e1, Expr2=e2)  with op = "&"
        | Expr.LogicalXor        (Expr1=e1, Expr2=e2)  with op = "~"
        | Expr.ShiftLeft         (Expr1=e1, Expr2=e2)  with op = "<<"
        | Expr.ShiftRight        (Expr1=e1, Expr2=e2)  with op = ">>"
        | Expr.Sum               (Expr1=e1, Expr2=e2)  with op = "+"
        | Expr.Sub               (Expr1=e1, Expr2=e2)  with op = "-"
        | Expr.Modulus           (Expr1=e1, Expr2=e2)  with op = "%"
        | Expr.Multiply          (Expr1=e1, Expr2=e2)  with op = "*"
        | Expr.Divide            (Expr1=e1, Expr2=e2)  with op = "/"
          => $<#($(GenerateScenarioFilterImpl(e1, dic)) $op $(GenerateScenarioFilterImpl(e2, dic)))#>
        | Expr.Cast           as e => $<#(($(e.TypeName))$(GenerateScenarioFilterImpl(e.Expression, dic)))#>

        | Expr.Conditional as e =>
        def type = e.Type.FullName;
        $<#($(GenerateScenarioFilterImpl(e.Condition, dic)) ? (($type)$(GenerateScenarioFilterImpl(e.Expr1, dic))) : (($type)$(GenerateScenarioFilterImpl(e.Expr2, dic))))#>

        | Expr.Argument as a => GenerateScenarioFilterImpl(a.Expr, dic)
        | Expr.MemberAccess1 as e =>
            def member = e.Ref.Symbol;
            if (e.Expr1.Type is Tdl.SuiteTypeSymbol && member is Tdl.FieldSymbol)
              $<#(($(e.Type))globals["$(member.Name)"])#>
            else
              GenerateScenarioFilterImpl(e.Expr1, dic) + "." + member.Name

        | Expr.SimpleName as e => GenerateBySymbol(e.Ref.Symbol, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    private GenerateSuiteGroup(suiteSymbol : Suite.ListSymbol, suiteGroups : IDictionary[string, SuiteGroup]) : void
    {
      def suites = List();
      foreach (symbol in suiteSymbol.AllSuites)
      {
        | s is Suite.DefSymbol       => suites.Add(s.Name)
        | s is Suite.GeneratorSymbol => suites.AddRange(suiteGroups[s.Name].Suites)
        | _ => assert2(false, $"Invalid symbol $(symbol) in AllSymbols")
      }

      suiteGroups.Add(suiteSymbol.Name, SuiteGroup() <- { Suites = suites })
    }

    private GenerateSuiteGenerator(g : Suite.GeneratorSymbol, suites : IDictionary[string, TestSuite], suiteGroups : IDictionary[string, SuiteGroup],
      scenarioTrigger : ScenarioTriggerProcessor) : void
    {
      def nameBase = g.Name;
      def names = List();

      foreach (dic in SubstituteVariables(g.Froms, 0))
      {
        def toString(e : Tdl.Expr) : string
        {
          | String as s => s.Value
          | _ => e.ToString()
        }
        def name = $<#$nameBase-..$(dic.Values; "-"; toString)#>;
        names.Add(name);
        def platform   = TryResolveVar(dic, g.Platform) : PlatformSymbol;
        def product    = TryResolveVar(dic, g.Product)  : ProductSymbol;

        def parameters = CollectDefs(g.Defs, dic);
        foreach (d when !parameters.ContainsKey(d.Name) in g.DefaultDefs)
          parameters.Add(d.Name, ParameterDefaultValue);
        
        def entityOpt = if (g.EntityOpt.HasValue) (TryResolveVar(dic, g.EntityOpt.Value)  : EntitySymbol).Name else null;
        def suite = TestSuite() <- 
        {
          Platforms     = array[platform.Name];
          Products      = array[product.Name];
          TestScenarios = GetSuiteScenarioList(g.Statements, scenarioTrigger);
          Parameters    = parameters;
          TestEntity    = entityOpt;
          DashboardVisibleParameters = GetDashboardVisibleParameters(g.Type, g.Statements);
        };

        suites.Add(name, suite);
      }

      suiteGroups.Add(nameBase, SuiteGroup() <- { Suites = names; });
    }

    private GenerateSuite(suiteSymbol : Suite.DefSymbol, scenarioTrigger : ScenarioTriggerProcessor) : TestSuite
    {
      def parameters = CollectDefs(suiteSymbol.Defs);
      foreach (d in suiteSymbol.DefaultDefs)
        parameters.Add(d.Name, ParameterDefaultValue);
      def entityOpt = suiteSymbol.EntityOpt;
      TestSuite() <- 
      {
        Platforms                  = array[suiteSymbol.Platform.Name];
        Products                   = array[suiteSymbol.Product.Name];
        TestScenarios              = GetSuiteScenarioList(suiteSymbol.Statements, scenarioTrigger);
        Parameters                 = parameters;
        TestEntity                 = if (entityOpt.HasValue) entityOpt.Value.Name else null;
        DashboardVisibleParameters = GetDashboardVisibleParameters(suiteSymbol.Type, suiteSymbol.Statements);
      }
    }

    private GetDashboardVisibleParameters(type : TypeSymbol, statements : ImmutableArray[SuiteStatement]) : List[string]
    {
      def result = SortedSet();

      foreach(field is FieldSymbol when field.IsIsDashboardVisibleEvaluated && field.IsDashboardVisible in type.Scope.AllSymbols)
        _ = result.Add(field.Name);

      foreach (call is Tdl.SuiteStatement.CallScenario in statements)
      foreach (symbol in call.Reference.DashboardVisibleParameters)
        _ = result.Add(symbol.Name);

      if (result.Count == 0) null else result.ToList()
    }

    private GetSuiteScenarioList(statements : ImmutableArray[SuiteStatement], scenarioTrigger : ScenarioTriggerProcessor) : array[string]
    {
      GetScenarioList(statements.OfType.[Tdl.SuiteStatement.CallScenario]().Select(c => c.Reference), scenarioTrigger)
    }

    private GetScenarioList(scenarios : Seq[ScenarioSymbol], scenarioTrigger : ScenarioTriggerProcessor) : array[string]
    {
      def names = List();
      foreach (scenario in scenarios)
      {
        when (IsScenarioTriggered(scenario, scenarioTrigger))
          names.Add(scenario.Name);
      }
      names.ToArray()
    }

    private IsScenarioTriggered(scenario : ScenarioSymbol, scenarioTrigger : ScenarioTriggerProcessor) : bool
    {
      scenarioTrigger == null || scenarioTrigger.IsTriggered(scenario)
    }
  } // module
} // namespace
