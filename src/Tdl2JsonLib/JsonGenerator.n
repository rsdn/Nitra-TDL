using DotNet;

using JsonDal;

using Microsoft.Cci.MetadataReader.ObjectModelImplementation;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Utility.Pair;

using Newtonsoft.Json;

using Nitra;
using Nitra.BackEnd.Cci;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using Microsoft.Cci;

using QuickType;
using Utils;

using System;
using System.Globalization;
using System.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;

using Tdl;
using Tdl2Json.ExceptionHelper;

namespace Tdl2Json
{
  public delegate TransfomationFunc(context : TransformationContext) : void;
  public delegate MessageHandler(text : string, importance : MessageImportance) : void;

  public enum MessageImportance
  {
    | Low
    | High
  }

  public module JsonGenerator
  {
    static JsonVersion : int = 7;
    public static DefaulteTimeout : TimeSpan = TimeSpan.FromMinutes(15);
    public IsExperimental = ThisAssembly.BranchName != "master";

    public event OnMessage : MessageHandler;

    public Generate(
      [NotNullOrEmpty] workingDirectory            : string,
      [NotNull]        sourceFiles                 : array[string],
      [NotNull]        references                  : array[string],
                       deploymentScriptHeader      : string,
               mutable deploymentToolPath          : string,
                       isMethodTypingEnabled       : bool,
                       output                      : Lazy[TextWriter],
                       transformatorOutput         : string,
                       transformatorOpt            : TransfomationFunc,
                       isTestMode                  : bool,
                       booleanMarshalMode          : BooleanMarshalMode,
                       jsonSchemaType              : string,
                       diffFile                    : string,
                       repositoryRoot              : string,
                       excludeTriggerPathScenarios : bool,
                       isSampleGeneration          : bool
      ) : TransformationContext
    {
      BooleanLiterals.Setup(booleanMarshalMode);

      def mode =
        match (isTestMode)
        {
          | true                             => CompilerMode.Test
          | _  when transformatorOpt != null => CompilerMode.Transform
          | _                                => CompilerMode.Compile
        };
      def absolutePaths = sourceFiles.Map(f => if(Path.IsPathRooted(f)) f else Path.Combine(workingDirectory, f));

      def CheckFilesExists(files, messageformatter : string -> string)
      {
        def notFoundFiles = files.Where(f => !File.Exists(f)).ToList();
        when (notFoundFiles.Any())
        {
          def messages = notFoundFiles.Select(messageformatter).ToArray();
          throw ConfigurationException(string.Join("\r\n", messages));
        }
      }

      CheckFilesExists(absolutePaths, m => $"File not found: $m");

      def context = Compile(workingDirectory, absolutePaths, references, isMethodTypingEnabled, mode, transformatorOutput);
      unless (context.Messages.HasErrors)
      {
        if (mode == CompilerMode.Transform)
          transformatorOpt(context);
        else
        {
          when (string.IsNullOrEmpty(deploymentToolPath))
            deploymentToolPath = <#.\KL.Autotests.Deployer.exe#>;

          GenerateJson(context, output, deploymentScriptHeader, deploymentToolPath, jsonSchemaType, diffFile, repositoryRoot,
            excludeTriggerPathScenarios, isSampleGeneration);
        }
      }

      context
    }

    private static StandardLibraries : array[LibReference] = array[
      FullNameLibReference("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"),
      FullNameLibReference("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"),
      FullNameLibReference("System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
    ];

    private Compile(directory : string, files : array[string], refs : array[string], isMethodTypingEnabled : bool, mode : CompilerMode,
      transformatorOutput : string) : TransformationContext
    {
      TdlTypingSettings.IsMethodTypingEnabled = isMethodTypingEnabled;

      def commentBag     = if (mode == CompilerMode.Compile) null else CommentBag();
      def solution       = FsSolution();
      def project        = FsProject(solution,
                                     directory,
                                     files.Map(FsFileWithId(_, TdlLang.Instance, commentBag)),
                                     StandardLibraries.Concat(refs.Select(FileLibReference)).ToArray());
      def stopwatch      = Stopwatch.StartNew();
      def projectSupport = ProjectSupport(testMode=true);
      ReportMessage("Loading types from referenced assemblies...");
      def data           = projectSupport.RefreshReferences(CancellationToken.None, project);
      ReportElapsedTime(stopwatch);

      ReportMessage("Parsing TDLs...");
      project.Data       = data;
      def files          = project.Files.Select(_.GetEvalPropertiesData()).ToImmutableArray();
      ReportElapsedTime(stopwatch);

      ReportMessage("Semantic analysis...");
      projectSupport.RefreshProject(CancellationToken.None, files, data);
      ReportElapsedTime(stopwatch);

      def messages = CompilerMessageBag(project.CompilerMessages :> CompilerMessageList);

      foreach (file when file.HasCompilerMessage in files)
        _ = messages.AddRange(file.GetCompilerMessage());

      foreach (file in project.Files)
        _ = messages.AddRange(file.GetCompilerMessages());

      def tdlProjectData = data :> TdlProjectData;
      def evalContext    = tdlProjectData.Context :> TdlDependentPropertyEvalContext;
      TransformationContext(tdlProjectData.RootNamespace, commentBag, messages, evalContext.InitialDeployment, evalContext.FinalDeployment,
        tdlProjectData.ExternalSymbolTable, transformatorOutput)
    }

    internal ReportMessage(msg : string, importance : MessageImportance = MessageImportance.High) : void
    {
      OnMessage?.Invoke(msg, importance);
    }

    private ReportElapsedTime(stopwatch : Stopwatch) : void
    {
      ReportMessage($"Elapsed time: $(stopwatch.Elapsed)");
      stopwatch.Restart();
    }

    private GenerateJson(context : TransformationContext, output : Lazy[TextWriter], deploymentScriptHeader : string, deploymentToolPath : string,
      mutable jsonSchemaType : string, diffFile : string, repositoryRoot : string, excludeTriggerPathScenarios : bool, isSampleGeneration : bool) : void
    {
      def stopwatch = Stopwatch.StartNew();
      JsonGenerator.ReportMessage("Generating JSON...");

      when (string.IsNullOrEmpty(jsonSchemaType))
        jsonSchemaType = if (IsExperimental) "dev" else "prod";

      def preSessionActionCompiler  = SessionActionCompiler(deploymentScriptHeader, deploymentToolPath);
      def postSessionActionCompiler = SessionActionCompiler(deploymentScriptHeader, deploymentToolPath);
      def deploymentCompiler        = DeploymentCompiler(deploymentScriptHeader, deploymentToolPath);
      def symbols                   = context.RootNamespace.MemberTable.GetAllSymbols().ToList();

      def scenarioTrigger =
        if (excludeTriggerPathScenarios)
          ExcludeTriggerPathScenarioTrigger.Instance
        else if (!string.IsNullOrEmpty(diffFile) && !string.IsNullOrEmpty(repositoryRoot))
        {
          def diffFileTrigger = DiffFileScenarioTrigger(repositoryRoot);
          foreach (scenario is ScenarioSymbol in symbols)
            diffFileTrigger.AddScenario(scenario);
          using (reader = StreamReader(diffFile))
            diffFileTrigger.LoadDiff(reader, diffFile);
          _ = context.Messages.AddRange(diffFileTrigger.Messages);
          diffFileTrigger
        }
        else
          DefaultScenarioTrigger.Instance;

      def platforms      = SortedDictionary();
      def products       = SortedDictionary();
      def entities       = SortedDictionary();
      def suites         = SortedDictionary();
      def suiteGroups    = SortedDictionary();
      def scenarios      = SortedDictionary();
      def vmCapabilities = SortedDictionary();

      foreach (s is PlatformSymbol in symbols)
        platforms.AddEx(s.Name, GeneratePlatform(s), "platforms");

      def platformNameSet = HashSet(platforms.Select(p => p.Key), StringComparer.InvariantCultureIgnoreCase);


      def barrierCompilerMap = PrepareBarrierCompilerMap(symbols);

      foreach (symbol in symbols)
      {
        try
          match (symbol)
          {
            | ProductSymbol         as s => products .AddEx(s.Name, GenerateProduct(s, platformNameSet), "products")
            | EntitySymbol          as s => entities .AddEx(s.Name, GenerateEntity(s), "entities")
            | Suite.DefSymbol       as s => suites   .AddEx(s.Name, GenerateSuite(s, scenarioTrigger,                      preSessionActionCompiler, postSessionActionCompiler), "suites")
            | Suite.GeneratorSymbol as s => GenerateSuiteGenerator             (s, suites, suiteGroups, scenarioTrigger, preSessionActionCompiler, postSessionActionCompiler)
            | Suite.ListSymbol      as s => GenerateSuiteGroup(s, suiteGroups)
            | ScenarioSymbol        as s when scenarioTrigger.IsTriggered(s) =>
              GenerateScenario(s, context.InitialDeployment, context.FinalDeployment, deploymentCompiler, scenarioTrigger, scenarios, barrierCompilerMap.Get(s))

            | VmCapabilitySymbol   as s when !(s.Value is Tdl.Expr.NotSet) =>
              def value = s.Value.ToObject();
              vmCapabilities.AddEx(s.Name, value, "vmCapabilities");

            | _ => ()
          }
        catch
        {
          | e is Exception =>
            throw InvalidOperationException($"Failed to generate code for '$symbol' symbol.", e)
        }
      }

      def defaultValues = SortedDictionary();
      when (vmCapabilities.Count > 0)
        defaultValues.AddEx("Capabilities", vmCapabilities, "defaultValues");

      foreach (f is FieldSymbol in context.ExternalSymbols.GetAllSymbols())
      {
        when (f.Value is VSome(v))
        {
          def value = v.ToObject();
          defaultValues.AddEx(f.Name, value, "defaultValues");
        }
      }

      unless (isSampleGeneration)
      {
        def version             = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;
        def versionPropertyName = "$TDL Compiler Version$";
        defaultValues.AddEx(versionPropertyName, version.ToString(), "defaultValues");
        def versionPropertyName = "$TDL Compilation Local Time$";
        defaultValues.AddEx(versionPropertyName, DateTime.Now, "defaultValues");
      }

      def config = Root() <-
      {
        Version            = JsonVersion;
        Schema             = $<#http://auto-reports.avp.ru/starter-schema/v$JsonVersion/$jsonSchemaType/schema.json#>;
        Deployments        = deploymentCompiler.GetResult();
        Products           = products;
        Platforms          = platforms;
        Suites             = suites;
        TestScenarios      = scenarios;
        SuiteGroups        = if (suiteGroups.Count == 0) null else suiteGroups;
        TestEntities       = entities;
        DefaultValues      = if (defaultValues.Count == 0) null else defaultValues;
        PreSessionActions  = preSessionActionCompiler.Compile();
        PostSessionActions = postSessionActionCompiler.Compile();
      };

      def settings = ConverterSettings.Settings <- Formatting = Formatting.Indented;
      def serializer = JsonSerializer.Create(settings);
      serializer.Serialize(output.Value, config);
      output.Value.Flush();

      ReportElapsedTime(stopwatch);
    }

    private PrepareBarrierCompilerMap(symbols : List[DeclarationSymbol]) : Hashtable[ScenarioSymbol, BarrierCompiler]
    {
      def barrierCompilerMap = Hashtable();

      foreach (Tdl.Scenario.SetSymbol(IsIsMultiMachineEvaluated=true, IsMultiMachine=true) as set in symbols)
      {
        def barrierCompiler = BarrierCompiler();
        def selfId          = set.Id;
        def scenarios       = set.AllScenarios.Where(x => x.Id != selfId).ToArray();
        barrierCompiler.ScanBarriers(scenarios);
        foreach (scenario in scenarios)
          barrierCompilerMap[scenario] = barrierCompiler;
      }

      barrierCompilerMap
    }

    private GeneratePlatform(platformSymbol : PlatformSymbol) : PlatformValue
    {
      | Platform.DefSymbol        => PlatformValue() <- { Platform    = Platform() }
      | Platform.SetSymbol as Set => PlatformValue() <- { StringArray = Set.Platforms.Select(_.Name).ToArray(); }
      | _                         => ThrowNotSupportedSymbol(platformSymbol)
    }

    private MakeDefs(defs : Seq[Def], defaults : ImmutableArray[FormalParameterSymbol], variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : Hashtable[string, object]
    {
      def (defs2, _) = CollectDefs(defs, variables);
      foreach (d when !defs2.ContainsKey(d.Name) in defaults)
        defs2.AddEx(d.Name, Tdl.Expr.NotSetValue, "defs2");
      defs2
    }

    private CollectDefs(defs : Seq[Def], variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : Hashtable[string, object] * SortedDictionary[string, object]
    {
      def vmCapabilities = SortedDictionary();
      def result = Hashtable();
      foreach(@def in defs)
      {
        def name = @def.Symbol.Name;
        def value = @def.Expr.ToObject(variables=variables);
        if (@def.Symbol is VmCapabilitySymbol)
          vmCapabilities.AddEx(name, value, "vmCapabilities");
        else
          result.AddEx(name, value, "result");
      }
      (result, vmCapabilities)
    }

    private GenerateProduct(productSymbol : ProductSymbol, platformNameSet : HashSet[string]) : ProductValue
    {
      match (productSymbol)
      {
        | Product.DefSymbol as Def =>
          def isPlatforms(x : Def) : bool
          {
            x.Symbol.Name.Equals("Platforms", StringComparison.CurrentCultureIgnoreCase)
          }
          def (parameters, vmCapabilities) = CollectDefs(Def.Defs.Where(x => !isPlatforms(x)));
          def useAsFixedParameter(name : string) : string
          {
            mutable value;
            if (parameters.TryGetValue(name, out value))
            {
              _ = parameters.Remove(name);
              value :> string
            }
            else
              null
          }
          def name = useAsFixedParameter("Name");
          parameters.AddEx("Name", name, "parameters");
          def expr = Def.Defs.FirstOrDefault(isPlatforms);
          def platforms =
            if (expr : object == null)
              null
            else
            {
              def platforms = expr.Expr.GetExprList().Select(_.ToString()).ToArray();
              if (platformNameSet.SetEquals(platforms))
                null // ignore if all platforms included
              else
                platforms.OrderBy(x => x).ToArray()
            };
          ProductValue() <-
          {
            Product = Product() <- {
              Name              = name;
              BranchName        = useAsFixedParameter("ReleaseName") ?? useAsFixedParameter("BranchName"); //
              Version           = useAsFixedParameter("Version");
              DumpServerProduct = useAsFixedParameter("DumpServerProduct");
              Parameters        = parameters;
              Platforms         = platforms;
              Capabilities      = if (vmCapabilities.Count > 0) vmCapabilities else null;
            }
          }
        | Product.SetSymbol as Set => ProductValue() <- { StringArray = Set.AllProducts.Select(p => p.Name).ToArray(); }
        | _ => ThrowNotSupportedSymbol(productSymbol)
      }
    }

    private GetAssemblyAndMethodName(expr : Tdl.Expr, variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : string * string
    {
      when (expr is Reference(Symbol=VarSymbol as v))
        return GetAssemblyAndMethodName(variables[v], variables);

      def (typeSymbolOpt, methodSymbol) =
        match (expr)
        {
          | Reference(Symbol=Member.MethodSymbol as m) => (null, m)
          | MemberAccess(Expr=MemberAccess(Symbol=GenericTypeSymbol as t), Symbol=Member.MethodSymbol as m)
          | MemberAccess(Expr=Reference   (Symbol=GenericTypeSymbol as t), Symbol=Member.MethodSymbol as m) => (t, m)
          | _ => assert(false, $"Unsupported method reference format '$expr' ($(expr.GetType().FullName))");
        };

      def decl         = methodSymbol.GetDeclarationsOfType.[ExternalMethodDeclaration]();
      def method       = decl.First().Method;
      def typeSymbol   = typeSymbolOpt :> SymbolBase;
      def type         = if (typeSymbol == null) method.ContainingType :> ITypeDefinition
                         else typeSymbol.GetDeclarationsOfType.[ExternalTopTypeDeclaration.[TopClassSymbol]]().First().Type;
      def unit         = TypeHelper.GetDefiningUnit(type);
      def assemblyName = unit.Name.Value + ".dll";
      def methodName   = type + "." + method.Name.Value;

      (assemblyName, methodName)
    }

    GetFixedString(g : Tdl.Scenario.GeneratorSymbol, name : string) : string
    {
      g.Defs.Find(d => d.Symbol.Name == name).Map(_.Expr).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
    }

    private SplitScenarioDefs(defs : ImmutableArray[Def], variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr]) : Hashtable[string, Tdl.Expr] * SortedDictionary[string, object]
    {
      def defTable       = Hashtable();
      def vmCapabilities = SortedDictionary();
      foreach (d in defs)
      {
        def key = d.Symbol.Name;
        if (d.Symbol is VmCapabilitySymbol)
        {
          def value = d.Expr.ToObject(variables=variables);
          vmCapabilities.AddEx(key, value, "vmCapabilities");
        }
        else
          defTable.AddEx(key, d.Expr, "defs");
      }
      (defTable, vmCapabilities)
    }
    
    private GenerateTestGroup(g : Tdl.Scenario.GeneratorSymbol, uniqueId : Guid, dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr],
      initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol, compiler : DeploymentCompiler,
      barrierCompilerOpt : option[BarrierCompiler]) : TestGroup
    {
      def (defs, vmCapabilities) = SplitScenarioDefs(g.Defs, dic);

      def getString(name : string) : string
      {
        def getValue(expr : Tdl.Expr) : string
        {
          | String as s => s.Value
          | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
          | Reference(Symbol=FieldSymbol(DeclaredIn=ExternalSymbol) as fld) => $"#($(fld.Name))"
          | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getBool(name : string) : bool?
      {
        def getValue(expr : Tdl.Expr) : bool?
        {
              | Tdl.Expr.True  => Nullable(true)
              | Tdl.Expr.False => Nullable(false)
              | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
              | _              => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getLong(name : string) : long?
      {
          def getValue(expr : Tdl.Expr) : long?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getInt(name : string) : int?
      {
          def getValue(expr : Tdl.Expr) : int?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          defs.Get(name).Map(getValue).WithDefault(null);
      }
      def deployment = Api.TryResolveVar(dic, g.Deployment) : DeploymentSymbol;
      def platform   = Api.TryResolveVar(dic, g.Platform)   : PlatformSymbol;
      def product    = Api.TryResolveVar(dic, g.Product)    : ProductSymbol;
      def artifactsCollectionTimeout = getString("ArtifactsCollectionTimeout");
      def getTestMethod() : TestMethod
      {
        def makeMethodAction(method : ScenarioAction.Method) : TestMethodQualifier
        {
          _ = method.Expr;
          def (assemblyName, methodName) = GetAssemblyAndMethodName(method.Expr, dic);
          TestMethodQualifier() <-
          {
            AssemblyName               = assemblyName;
            MethodName                 = methodName;
            MaxRebootsCount            = method.MaxRebootsCountOpt.ExprToInt(dic);
            ContinueOnError            = method.ContinueOnErrorOpt.ToNullable();
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
            LocalTestBinariesFolder    = method.BinariesFolderOpt.ExprToString(dic);
          }
        }

        when (g.Actions.Length == 1)
        when (g.Actions[0] is ScenarioAction.Method as method)
          return makeMethodAction(method);

        def makeScriptAction(c : ScenarioAction.Script) : UnixScriptRunner
        {
            def testScriptArgs = string.Join(" ", c.Arguments.Select(a => a.ExprToString(dic)));
            def env = c.Defs.Select(d => (d.Symbol.Name, d.Expr.ToObject(values=null, variables=dic))).ToDictionary();
            UnixScriptRunner() <-
            {
              TestScriptName             = c.Name.ExprToString(dic);
              TestScriptArgs             = testScriptArgs;
              Environment                = env;
              MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
              ArtifactsCollectionTimeout = artifactsCollectionTimeout;
            }
        }
        def makeGTestAction(c : ScenarioAction.GTest) : GTestProgram
        {
            def testScriptArgs = c.Arguments.MapToArray(a => a.ExprToString(dic));
            GTestProgram() <-
            {
              ProgramName                = c.Name.ExprToString(dic);
              Arguments                  = testScriptArgs;
              MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
              ArtifactsCollectionTimeout = artifactsCollectionTimeout;
            }
        }
        def makeXCodeAction(c : ScenarioAction.XCode) : XCode
        {
            XCode() <-
            {
              XCodeTestContainer         = c.Container.ExprToString(dic);
              XcodePath                  = c.XcodePath.ExprToString(dic);
              MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
              ArtifactsCollectionTimeout = artifactsCollectionTimeout;
            }
        }
        def makeVsTestAction(c : ScenarioAction.VsTest) : VsTest
        {
            VsTest() <-
            {
              VsTestAssemblyName         = c.Container.ExprToString(dic);
              VsTestRunCmdLine           = c.VsTestRunCmdLineOpt.ExprToString(dic);
              TestCaseFilter             = c.FilterOpt.ExprToString(dic);
              Platform                   = c.VsTestPlatformOpt.ExprToString(dic);
              Framework                  = c.VsTestFrameworkOpt.ExprToString(dic);
              AdditionalOptions          = c.VsTestAdditionalOptionsOpt.ExprToString(dic);
              MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
              ArtifactsCollectionTimeout = artifactsCollectionTimeout;
            }
        }
        def makeAndroidJavaAction(c : ScenarioAction.Apk) : AndroidJava
        {
            AndroidJava() <-
            {
              AndroidTestContainer       = c.Name.ExprToString(dic);
              TestFilter                 = c.FilterOpt.ExprToString(dic);
              TestRunnerPath             = c.RunnerPath.ExprToString(dic);
              MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            }
        }
        def makeMarathonAction(c : ScenarioAction.Marathon) : Marathon
        {
            Marathon() <-
            {
              AndroidTestContainer       = c.TestContainerApk.ExprToString(dic);
              AndroidTestContainer       = c.AppApk.ExprToString(dic);
              MarathonTestRunnerPath     = c.RunnerPath.ExprToString(dic);
              TestFilter                 = c.Filter.ExprToString(dic);
              LocalTestBinariesFolder    = c.BinariesFolder.ExprToString(dic);
              MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            }
        }
        def makeConfigAction(c : ScenarioAction.Config) : TestBot
        {
          TestBot() <-
          {
            TestConfigName             = c.path.ExprToString(dic);
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          }
        }
        def makeAction(action : ScenarioAction) : TestSequenceItem
        {
          | Reboot             => RebootTestStep() <- { ForceReboot = RebootTestStep.Data() }
          | Method        as method => makeMethodAction(method)
          | WaitForReboot as wbr =>
            WaitForRebootTestStep() <-
            {
              WaitForReboot =
                WaitForRebootTestStep.Data() <-
                {
                  RebootTimeout   = if (string.IsNullOrEmpty(wbr.TimeSpan)) "00:05:00" else wbr.TimeSpan;
                  MaxRebootsCount = wbr.MaxRebootsCountOpt.ExprToInt();
                };
            }
          | BarrierGenerator as bg => MakeBarrier(dic, barrierCompilerOpt, bg)
          | Barrier as barrier => MakeBarrier(barrierCompilerOpt, barrier)
          | Script as s        => makeScriptAction(s)
          | Config as c        => makeConfigAction(c)
          | GTest  as g        => makeGTestAction(g)
          | XCode  as x        => makeXCodeAction(x)
          | VsTest as x        => makeVsTestAction(x)
          | Apk    as a        => makeAndroidJavaAction(a)
          | Marathon as m      => makeMarathonAction(m)
          | Login  as login    => LoginTestStep() <-
            {
              Login = LoginTestStep.Data() <-
              {
                User = login.User.ExprToString(dic);
                Password = login.Password.ExprToString(dic);
              }
            }

          | Logoff             => LogoffTestStep() <- { Logoff = LogoffTestStep.Data() }
          | LockWorkstation    => LockWorkstationTestStep() <- { LockWorkstation = LockWorkstationTestStep.Data() }
          | _                  => assert(false, "Unsupported ScenarioAction: " + action)
        }
        def tryGetSingleElem[T]() : ValueOption[T]
        {
          if (g.Actions.Length == 1 && g.Actions[0] is T) VSome(g.Actions[0] :> T) else VNone()
        }

        if (tryGetSingleElem() is VSome(action))
          makeConfigAction(action)
        else if (tryGetSingleElem() is VSome(action))
          makeScriptAction(action)
        else if (tryGetSingleElem() is VSome(action))
          makeGTestAction(action)
        else if (tryGetSingleElem() is VSome(action))
          makeXCodeAction(action)
        else if (tryGetSingleElem() is VSome(action))
          makeVsTestAction(action)
        else if (tryGetSingleElem() is VSome(action))
          makeAndroidJavaAction(action)
        else
          TestMethodSequence() <-
          {
            TestSequence               = g.Actions.Select(makeAction).ToArray();
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          }
      }
      def assignedParams = g.Defs.FilterToArray(d => d.Symbol.IsDeclaredInOptEvaluated && d.Symbol.DeclaredInOpt.HasValue && d.Symbol.DeclaredInOpt.Value is DeploymentSymbol);

      def testGroup =
        TestGroup() <-
        {
          Deployments             = GetTestGroupDeployments(initialDeployment, finalDeployment, deployment, compiler, assignedParams, dic);
          Environments            = array[EnvironmentElement() <- { Platforms= array[platform.Name]; Products=array[product.Name]; }];
          TestMethod              = getTestMethod();
          Area                    = getString("Area");
          ExternalAutotestId      = getInt   ("ExternalAutotestId");
          LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
          NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
          RequireInternet         = getBool  ("RequireInternet");
          RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
          RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
          Responsible             = getString("Responsible");
          RevertAgentAfter        = getBool  ("RevertAgentAfter") ?? true;
          RevertAgentBefore       = getBool  ("RevertAgentBefore");
          TfsId                   = getLong  ("TfsId");
          Timeout                 = getString("Timeout");
          UniqueId                = uniqueId;
          ProductGroupName        = getString("ProductGroupName");
          FilterExpression        = GenerateScenarioFilter(g.Filter :> DotNet.ExprBase, dic);
          MultiMachineId          = if (barrierCompilerOpt is Some(compiler)) compiler.MultiMachineId else null;
          Capabilities            = if (vmCapabilities.Count > 0) vmCapabilities else null;
        };

      testGroup
    }

    private MakeBarrier(barrierCompilerOpt : option[BarrierCompiler], b : ScenarioAction.Barrier) : WaitForBarrierTestStep
    {
      def barrierCompiler = barrierCompilerOpt.UnSome();
      def (count, guid)   = barrierCompiler.GetBarrierInfo(b.barrier.Name);
      WaitForBarrierTestStep() <-
      {
        WaitForBarrier =
          WaitForBarrierTestStep.Data() <-
          {
            Id      = guid;
            Timeout = TimeSpan.Parse(b.barrier.Timeout.Value);
            Count   = count;
          }
      }
    }

    private MakeBarrier(dic : Dictionary[TypedDeclarationSymbol, Tdl.Expr], barrierCompilerOpt : option[BarrierCompiler], bg : ScenarioAction.BarrierGenerator) : WaitForBarrierTestStep
    {
      def barrierCompiler = barrierCompilerOpt.UnSome();
      def (count, guid)   = barrierCompiler.GetBarrierInfo(dic, bg);
      WaitForBarrierTestStep() <-
      {
        WaitForBarrier =
          WaitForBarrierTestStep.Data() <-
          {
            Id      = guid;
            Timeout = bg.Timeout;
            Count   = count;
          }
      }
    }

    private GenerateScenario(scenarioSymbol : ScenarioSymbol, initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol,
      compiler : DeploymentCompiler, scenarioTrigger : IScenarioTrigger, scenarios : IDictionary[string, TestCase],
      barrierCompilerOpt : option[BarrierCompiler]) : void
    {
      def addTestCase(name, testGroup)
      {
        scenarios.AddEx(name, TestCase() <- { TestGroup = testGroup; }, "scenarios");
      }

      match (scenarioSymbol)
      {
        | Tdl.Scenario.SetSymbol as s => addTestCase(scenarioSymbol.Name, TestGroup() <- { TestScenarios = GetScenarioList(s.Scenarios, scenarioTrigger) });
        | Tdl.Scenario.DefSymbol as r =>
          def (defs, vmCapabilities) = SplitScenarioDefs(r.Defs, null);

          def getString(name : string) : string
          {
            defs.Get(name).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
          }
          def getGuid(name : string) : Guid?
          {
            def str = defs.Get(name).Map(expr => (expr :> Tdl.Expr.String).Value).WithDefault(null);
            if (string.IsNullOrWhiteSpace(str))
              null
            else
              Guid.Parse(str)
          }
          def getBool(name : string) : bool?
          {
            def toNullable(expr)
            {
              | Tdl.Expr.True  => Nullable(true)
              | Tdl.Expr.False => Nullable(false)
              | _              => throw NotSupportedException($"Supported expression '$expr' (Tdl.Expr.$(expr.GetType().Name))")
            }
            defs.Get(name).Map(toNullable).WithDefault(null);
          }
          def getLong(name : string) : long?
          {
              defs.Get(name).Map(expr => Nullable((expr :> Tdl.Expr.Integer).Value)).WithDefault(null);
          }
          def getInt(name : string) : int?
          {
              defs.Get(name).Map(expr => Nullable((expr :> Tdl.Expr.Integer).Value)).WithDefault(null);
          }
          def artifactsCollectionTimeout = getString("ArtifactsCollectionTimeout");
          def getTestMethod() : TestMethod
          {
            def makeMethodAction(method : ScenarioAction.Method) : TestMethodQualifier
            {
              _ = method.Expr;
              def (assemblyName, methodName) = GetAssemblyAndMethodName(method.Expr);
              TestMethodQualifier() <-
              {
                AssemblyName               = assemblyName;
                MethodName                 = methodName;
                MaxRebootsCount            = method.MaxRebootsCountOpt.ExprToInt();
                ContinueOnError            = method.ContinueOnErrorOpt.ToNullable();
                ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                LocalTestBinariesFolder    = method.BinariesFolderOpt.ExprToString();
              }
            }

            when (r.Actions.Length == 1)
            when (r.Actions[0] is ScenarioAction.Method as method)
              return makeMethodAction(method);

            def makeScriptAction(c : ScenarioAction.Script) : UnixScriptRunner
            {
                def testScriptArgs = string.Join(" ", c.Arguments.Select(a => a.ExprToString().ToLiteral()));
                def env = c.Defs.Select(d => (d.Symbol.Name, d.Expr.ToObject())).ToDictionary();
                UnixScriptRunner() <-
                {
                  TestScriptName             = c.Name.ExprToString();
                  TestScriptArgs             = testScriptArgs;
                  Environment                = env;
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeGTestAction(c : ScenarioAction.GTest) : GTestProgram
            {
                def testScriptArgs = c.Arguments.MapToArray(a => a.ExprToString());
                GTestProgram() <-
                {
                  ProgramName                = c.Name.ExprToString();
                  Arguments                  = testScriptArgs;
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeXCodeAction(c : ScenarioAction.XCode) : XCode
            {
                XCode() <-
                {
                  XCodeTestContainer         = c.Container.ExprToString();
                  XcodePath                  = c.XcodePath.ExprToString();
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeVsTestAction(c : ScenarioAction.VsTest) : VsTest
            {
                VsTest() <-
                {
                  VsTestAssemblyName         = c.Container.ExprToString();
                  VsTestRunCmdLine           = c.VsTestRunCmdLineOpt.ExprToString();
                  TestCaseFilter             = c.FilterOpt.ExprToString();
                  Platform                   = c.VsTestPlatformOpt.ExprToString();
                  Framework                  = c.VsTestFrameworkOpt.ExprToString();
                  AdditionalOptions          = c.VsTestAdditionalOptionsOpt.ExprToString();
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                  ArtifactsCollectionTimeout = artifactsCollectionTimeout;
                }
            }
            def makeAndroidJavaAction(c : ScenarioAction.Apk) : AndroidJava
            {
                AndroidJava() <-
                {
                  AndroidTestContainer       = c.Name.ExprToString();
                  TestFilter                 = c.FilterOpt.ExprToString();
                  TestRunnerPath             = c.RunnerPath.ExprToString();
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                }
            }
            def makeMarathonAction(c : ScenarioAction.Marathon) : Marathon
            {
                Marathon() <-
                {
                  AndroidTestContainer       = c.TestContainerApk.ExprToString();
                  AndroidTestContainer       = c.AppApk.ExprToString();
                  MarathonTestRunnerPath     = c.RunnerPath.ExprToString();
                  TestFilter                 = c.Filter.ExprToString();
                  LocalTestBinariesFolder    = c.BinariesFolder.ExprToString();
                  MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                }
            }
            def makeConfigAction(c : ScenarioAction.Config) : TestBot
            {
              TestBot() <-
              {
                TestConfigName             = c.path.ExprToString();
                MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt();
                ArtifactsCollectionTimeout = artifactsCollectionTimeout;
              }
            }
            def makeAction(action : ScenarioAction) : TestSequenceItem
            {
              | Reboot             => RebootTestStep() <- { ForceReboot = RebootTestStep.Data() }
              | Method        as m => makeMethodAction(m)
              | WaitForReboot as wbr =>
                WaitForRebootTestStep() <-
                {
                  WaitForReboot =
                    WaitForRebootTestStep.Data() <-
                    {
                      RebootTimeout   = if (string.IsNullOrEmpty(wbr.TimeSpan)) "00:05:00" else wbr.TimeSpan;
                      MaxRebootsCount = wbr.MaxRebootsCountOpt.ExprToInt();
                    };
                }
              | BarrierGenerator as bg => MakeBarrier(Dictionary(), barrierCompilerOpt, bg)
              | Barrier as barrier => MakeBarrier(barrierCompilerOpt, barrier)
              | Script as s        => makeScriptAction(s)
              | Config as c        => makeConfigAction(c)
              | GTest  as g        => makeGTestAction(g)
              | XCode  as x        => makeXCodeAction(x)
              | VsTest as x        => makeVsTestAction(x)
              | Apk    as a        => makeAndroidJavaAction(a)
              | Marathon as m      => makeMarathonAction(m)
              | Login  as login    => LoginTestStep() <-
                {
                  Login = LoginTestStep.Data() <-
                  {
                    User = login.User.ExprToString();
                    Password = login.Password.ExprToString()
                  }
                }

              | Logoff             => LogoffTestStep() <- { Logoff = LogoffTestStep.Data() }
              | LockWorkstation    => LockWorkstationTestStep() <- { LockWorkstation = LockWorkstationTestStep.Data() }
              | _                  => assert(false, "Unsupported ScenarioAction: " + action)
            }

            def tryGetSingleElem[T]() : ValueOption[T]
            {
              if (r.Actions.Length == 1 && r.Actions[0] is T) VSome(r.Actions[0] :> T) else VNone()
            }

            if (tryGetSingleElem() is VSome(action))
              makeConfigAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeScriptAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeGTestAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeXCodeAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeVsTestAction(action)
            else if (tryGetSingleElem() is VSome(action))
              makeAndroidJavaAction(action)
            else
              TestMethodSequence() <-
              {
                TestSequence               = r.Actions.Select(makeAction).ToArray();
                ArtifactsCollectionTimeout = artifactsCollectionTimeout;
              }
          }
          def assignedParams = r.Defs.FilterToArray(d => d.Symbol.IsDeclaredInOptEvaluated && d.Symbol.DeclaredInOpt.HasValue && d.Symbol.DeclaredInOpt.Value is DeploymentSymbol);
          def testGroup =
            TestGroup() <-
            {
                Deployments             = GetTestGroupDeployments(initialDeployment, finalDeployment, r.Deployment, compiler, assignedParams, null);
                Environments            = r.Environments.MapToArray(env => EnvironmentElement() <- { Platforms= array[env.Platform.Name]; Products=array[env.Product.Name]; });
                TestMethod              = getTestMethod();
                Area                    = getString("Area");
                LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
                ExternalAutotestId      = getInt   ("ExternalAutotestId");
                NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
                RequireInternet         = getBool  ("RequireInternet");
                RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
                RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
                Responsible             = getString("Responsible");
                RevertAgentAfter        = getBool  ("RevertAgentAfter") ?? true;
                RevertAgentBefore       = getBool  ("RevertAgentBefore");
                TfsId                   = getLong  ("TfsId");
                Timeout                 = getString("Timeout");
                UniqueId                = getGuid  ("UniqueId");
                ProductGroupName        = getString("ProductGroupName");
                FilterExpression        = GenerateScenarioFilter(r.Filter :> DotNet.ExprBase, ImmutableDictionary.Empty);
                MultiMachineId          = if (barrierCompilerOpt is Some(compiler)) compiler.MultiMachineId else null;
                Capabilities            = if (vmCapabilities.Count > 0) vmCapabilities else null;
            };
          addTestCase(scenarioSymbol.Name, testGroup);

        | Tdl.Scenario.GeneratorSymbol as g =>
          mutable counter : uint = 0;
          def incGuid(guid : Guid) : Guid
          {
            def bytes1   = guid.ToByteArray();
            def version  = BitConverter.ToUInt32(bytes1, 0) + counter;
            def bytes2   = BitConverter.GetBytes(version);
            bytes1[0] = bytes2[0];
            bytes1[1] = bytes2[1];
            bytes1[2] = bytes2[2];
            bytes1[3] = bytes2[3];
            Guid(bytes1)
          }
          mutable uniqueId = Guid.Parse(GetFixedString(g, "UniqueId"));
          def names = List();
          foreach (dic in Api.SubstituteVariables(g.Froms, 0))
          {
            counter++;
            def name = scenarioSymbol.Name + "-" + counter;
            names.Add(name);
            addTestCase(name, GenerateTestGroup(g, uniqueId, dic, initialDeployment, finalDeployment, compiler, barrierCompilerOpt));
            uniqueId = incGuid(uniqueId);
          }
          def testGroup = TestGroup() <- { TestScenarios = names.ToArray() };
          addTestCase(scenarioSymbol.Name, testGroup);

        | _ => _ = ThrowNotSupportedSymbol(scenarioSymbol)
      }
    }

    private GetTestGroupDeployments(initialDeployment  : DeploymentSymbol,
                                    finalDeployment    : DeploymentSymbol,
                                    scenarioDeployment : DeploymentSymbol,
                                    compiler           : DeploymentCompiler,
                                    assignedParams     : array[Def],
                                    dic                : Dictionary[TypedDeclarationSymbol, Tdl.Expr]) : array[TestGroupDeployment]
    {
      mutable deployments = if (finalDeployment == null) [] else [finalDeployment];

      when (!NList.Contains(deployments, scenarioDeployment))
        deployments ::= scenarioDeployment;

      when (initialDeployment != null && !NList.Contains(deployments, initialDeployment))
        deployments ::= initialDeployment;

      def scope                = HashSet(scenarioDeployment.AggregateParametersScope.GetAllSymbols().Select(s => s.Name), StringComparer.OrdinalIgnoreCase);
      def sortedAssignedParams = assignedParams.Where(x => scope.Contains(x.Symbol.Name)).Select(x => (x.Symbol.Name, x.Expr.ToObject(null, dic))).OrderBy((n, _) => n).NToList();
      def result               = compiler.Compile(deployments, sortedAssignedParams);
      compiler.GetCompositeDeployment(scenarioDeployment.Name, result)
    }

    private GenerateEntity(symbol : EntitySymbol) : TestEntity
    {
      def (parameters, _) = CollectDefs(symbol.Defs);
      TestEntity() <-
      {
        BranchName = parameters["BranchName"].ToString();
        Name       = parameters["Name"      ].ToString();
        Type       = parameters["Type"      ].ToString();
        Version    = parameters["Version"   ].ToString();
      }
    }

    private GenerateScenarioFilter() : string
    {
      null
    }

    private GenerateScenarioFilter(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      def result = GenerateScenarioFilterImpl(expr, dic);
      result
    }

    private GenerateTdlExpr(expr : Tdl.Expr, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | NotSet                        => "\"" + Tdl.Expr.NotSetValue + "\""
        | Error                         => GenerateScenarioFilter()
        | String(null)                  => "null"
        | String(s)                     => $<#@"$(s.Replace("\"", "\"\""))"#>
        | True                          => "true"
        | False                         => "false"
        | Real(num)                     => num.ToString(CultureInfo.InvariantCulture)
        | Integer(num)                  => num.ToString(CultureInfo.InvariantCulture)
        | Reference(symbol)             => GenerateBySymbol(symbol, dic)
        | MemberAccess(expr, member, _) => GenerateTdlExpr(expr, dic) + "." + member.InitialName
        | Tuple(items, _) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#(..$args)#>

        | List(items, type) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#new $(type.FullName)[] { ..$args }#>
      }
    }

    private GenerateDefaultValue(value : DotNet.DefaultValue) : string
    {
      | Null                  => "null"
      | String(null)          => "null"
      | String(s)             => $<#@"$(s.Replace("\"", "\"\""))"#>
      | Bool(true)            => "true"
      | Bool(false)           => "false"
      | Number(num, true, _)  => num.ToString(CultureInfo.InvariantCulture)
      | Number(num, false, _) => unchecked(num :> long).ToString(CultureInfo.InvariantCulture)
      | Decimal(num)          => num.ToString(CultureInfo.InvariantCulture)
      | Double(num)           => num.ToString(CultureInfo.InvariantCulture)
      | Single(num)           => num.ToString(CultureInfo.InvariantCulture)
      | t                     => throw NotSupportedException($"$(t.GetType().Name) is not supported in scenario parameters")
    }

    private GenerateBySymbol(symbol : DeclarationSymbol, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      mutable tdlExpr;
      match (symbol)
      {
        | FieldSymbol as fld =>
          match (fld.DeclaredIn)
          {
            | ExternalSymbol =>
              def type = fld.Type.FullName;
              def name = fld.Name;
              $<#(($type)externals["$name"])#>

            | _ => GenerateScenarioFilter()
          }

        | FormalParameterSymbol as p =>
          def type =
            match (p.Type)
            {
              | SuiteTypeSymbol => "TestSuite"
              | _ => p.Type.FullName
            };

          def name = p.Name;
          def getValue =
            match (type)
            {
              | "System.Boolean" | "bool" => $<#System.Convert.ToBoolean(globals["$name"])#>
              | _                         => $<#($type)globals["$name"]#>
            };

          if (p.HasDefault())
          {
            def defaultValue = GenerateDefaultValue(p.Default);
            $<#(globals.ContainsKey("$name") ? $getValue : $defaultValue)#>
          }
          else
            $<#($getValue)#>

        | Member.MethodSymbol as m => m.Name
        | PlatformSymbol as p => $<#config.Platforms["$(p.Name)"]#>
        | ProductSymbol  as p => $<#config.Products["$(p.Name)"]#>
        | TypedDeclarationSymbol as s when dic.TryGetValue(s, out tdlExpr) => GenerateTdlExpr(tdlExpr, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    public static ToFullNameString(symbol : TypeSymbol) : string
    {
      | DotNet.TopConstructedTypeSymbol as s =>
        def fullName = AstUtils.MakeFullName(s.TypeInfo.DeclaredInOpt, s.TypeInfo.Name, s.Args);
        fullName

      | _ => GenerateScenarioFilter()
    }

    private GenerateScenarioFilterImpl(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | null => null
        | Expr.Is as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) is $(e.TypeNameType))#>
        | Expr.As as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) as $(e.Type))#>
        | DotNet.IntegerLiteral
        | DotNet.RealLiteral
        | DotNet.Expr.BooleanLiteral
        | DotNet.Expr.Char
        | DotNet.Expr.String => expr.ToString().Trim()
        | Expr.Invocation as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))(..$args)#>;

        | Expr.IndexerAccess as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))[..$args]#>;

        | Expr.Parenthesized   as e => GenerateScenarioFilterImpl(e.Expression, dic)
        | Expr.PostDecrement (Expr1=e) with op = "++"
        | Expr.PostIncrement (Expr1=e) with op = "--"
          => $<#$(GenerateScenarioFilterImpl(e, dic))$op#>

        | Expr.PreIncrement    (Expr1=e) with op = "++"
        | Expr.PreDecrement    (Expr1=e) with op = "--"
        | Expr.BitwiseNegation (Expr1=e) with op = "~"
        | Expr.LogicalNegation (Expr1=e) with op = "!"
        | Expr.Negation        (Expr1=e) with op = "-"
          => $<#$op$(GenerateScenarioFilterImpl(e, dic))#>

        | Expr.TypeOf as e => $<#typeof($(e.Type))#>
        | Expr.GreaterThanOrEqual(Expr1=e1, Expr2=e2)  with op = ">="
        | Expr.LessThanOrEqual   (Expr1=e1, Expr2=e2)  with op = "<="
        | Expr.Less              (Expr1=e1, Expr2=e2)  with op =  "<"
        | Expr.Greater           (Expr1=e1, Expr2=e2)  with op =  ">"
        | Expr.ConditionalAnd    (Expr1=e1, Expr2=e2)  with op = "&&"
        | Expr.ConditionalOr     (Expr1=e1, Expr2=e2)  with op = "||"
        | Expr.Equal             (Expr1=e1, Expr2=e2)  with op = "=="
        | Expr.NotEqual          (Expr1=e1, Expr2=e2)  with op = "!="
        | Expr.NullCoalescing    (Expr1=e1, Expr2=e2)  with op = "??"
        | Expr.LogicalOr         (Expr1=e1, Expr2=e2)  with op = "|"
        | Expr.LogicalAnd        (Expr1=e1, Expr2=e2)  with op = "&"
        | Expr.LogicalXor        (Expr1=e1, Expr2=e2)  with op = "~"
        | Expr.ShiftLeft         (Expr1=e1, Expr2=e2)  with op = "<<"
        | Expr.ShiftRight        (Expr1=e1, Expr2=e2)  with op = ">>"
        | Expr.Sum               (Expr1=e1, Expr2=e2)  with op = "+"
        | Expr.Sub               (Expr1=e1, Expr2=e2)  with op = "-"
        | Expr.Modulus           (Expr1=e1, Expr2=e2)  with op = "%"
        | Expr.Multiply          (Expr1=e1, Expr2=e2)  with op = "*"
        | Expr.Divide            (Expr1=e1, Expr2=e2)  with op = "/"
          => $<#($(GenerateScenarioFilterImpl(e1, dic)) $op $(GenerateScenarioFilterImpl(e2, dic)))#>
        | Expr.Cast           as e => $<#(($(e.TypeName))$(GenerateScenarioFilterImpl(e.Expression, dic)))#>

        | Expr.Conditional as e =>
        def type = e.Type.FullName;
        $<#($(GenerateScenarioFilterImpl(e.Condition, dic)) ? (($type)$(GenerateScenarioFilterImpl(e.Expr1, dic))) : (($type)$(GenerateScenarioFilterImpl(e.Expr2, dic))))#>

        | Expr.Argument as a => GenerateScenarioFilterImpl(a.Expr, dic)
        | Expr.MemberAccess1 as e =>
            def member = e.Ref.Symbol;
            if (e.Expr1.Type is Tdl.SuiteTypeSymbol && member is Tdl.FieldSymbol)
              $<#(($(e.Type))globals["$(member.Name)"])#>
            else
              GenerateScenarioFilterImpl(e.Expr1, dic) + "." + member.Name

        | Expr.SimpleName as e => GenerateBySymbol(e.Ref.Symbol, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    private GenerateSuiteGroup(suiteSymbol : Suite.ListSymbol, suiteGroups : IDictionary[string, SuiteGroup]) : void
    {
      def suites = List();
      foreach (symbol in suiteSymbol.AllSuites)
      {
        | s is Suite.DefSymbol       => suites.Add(s.Name)
        | s is Suite.GeneratorSymbol => suites.AddRange(suiteGroups.GetValue(s.Name, "suiteGroups").Suites)
        | _ => assert2(false, $"Invalid symbol $(symbol) in AllSymbols")
      }

      suiteGroups.AddEx(suiteSymbol.Name, SuiteGroup() <- { Suites = suites }, "suiteGroups")
    }

    private TryGenerateAction(
      actionName : string,
      gen : Suite.GeneratorSymbol,
      product : ProductSymbol,
      variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr],
      sessionActionCompiler : SessionActionCompiler
    ) : string
    {
      def sessionActionOpt = gen.Predefineds.Find(p => p.Symbol.Name == actionName);
      match (sessionActionOpt)
      {
        | Some(Def(Expr=Tdl.Expr.Reference(Symbol=TypedDeclarationSymbol as td))) with d = Api.TryResolveVarOrNull(variables, td)
        | Some(Def(Expr=Tdl.Expr.Reference(Symbol=DeploymentSymbol as d))) when d != null =>
          def resultOpt = Api.MakeDeploymentsTree(d, product, gen.Defs, gen.DefaultDefs, variables);
          when (resultOpt is VSome(tree))
            return sessionActionCompiler.GetSessionActionName(tree, variables)

        | _ => ()
      }
      null
    }

    private GenerateSuiteGenerator(
      gen                       : Suite.GeneratorSymbol,
      suites                    : IDictionary[string, TestSuite],
      suiteGroups               : IDictionary[string, SuiteGroup],
      scenarioTrigger           : IScenarioTrigger,
      preSessionActionCompiler  : SessionActionCompiler,
      postSessionActionCompiler : SessionActionCompiler
    ) : void
    {
      def nameBase = gen.Name;
      def names = List();

      foreach (dic in Api.SubstituteVariables(gen.Froms, 0))
      {
        def toString(e : Tdl.Expr) : string
        {
          | String as s => s.Value
          | _ => e.ToString()
        }
        def name               = $<#$nameBase-..$(dic.Values; "-"; toString)#>;
        names.Add(name);
        def platform           = Api.TryResolveVar(dic, gen.Platform) : PlatformSymbol;
        def product            = Api.TryResolveVar(dic, gen.Product)  : ProductSymbol;
        def entityOpt          = if (gen.EntityOpt.HasValue) (Api.TryResolveVar(dic, gen.EntityOpt.Value) : EntitySymbol).Name else null;
        def defs               = MakeDefs(gen.Defs, gen.DefaultDefs, dic);
        def sessionInitializer = TryGenerateAction("SessionInitializer", gen, product, dic, preSessionActionCompiler);
        def sessionFinalizer   = TryGenerateAction("SessionFinalizer",   gen, product, dic, postSessionActionCompiler);

        def suite = TestSuite() <-
        {
          Platforms                  = array[platform.Name];
          Products                   = array[product.Name];
          TestScenarios              = GetSuiteScenarioList(gen.Statements, scenarioTrigger);
          Parameters                 = defs;
          TestEntity                 = entityOpt;
          DashboardVisibleParameters = GetDashboardVisibleParameters(gen.Defs);
          PreSessionAction           = sessionInitializer;
          PostSessionAction          = sessionFinalizer;
        };

        suites.AddEx(name, suite, "suites");
      }

      suiteGroups.AddEx(nameBase, SuiteGroup() <- { Suites = names; }, "suiteGroups");
    }

    private GenerateSuite(suiteSymbol : Suite.DefSymbol, scenarioTrigger : IScenarioTrigger, preSessionActionCompiler : SessionActionCompiler, postSessionActionCompiler : SessionActionCompiler) : TestSuite
    {
      def defs                  = MakeDefs(suiteSymbol.Defs, suiteSymbol.DefaultDefs);
      def sessionInitializerOpt = if (suiteSymbol.SessionInitializer is VSome(init)) preSessionActionCompiler .GetSessionActionName(init, variables=null) else null;
      def sessionFinalizerOpt   = if (suiteSymbol.SessionFinalizer   is VSome(init)) postSessionActionCompiler.GetSessionActionName(init, variables=null) else null;
      def entityOpt             = suiteSymbol.EntityOpt;
      TestSuite() <-
      {
        Platforms                  = array[suiteSymbol.Platform.Name];
        Products                   = array[suiteSymbol.Product.Name];
        TestScenarios              = GetSuiteScenarioList(suiteSymbol.Statements, scenarioTrigger);
        Parameters                 = defs;
        TestEntity                 = if (entityOpt.HasValue) entityOpt.Value.Name else null;
        DashboardVisibleParameters = GetDashboardVisibleParameters(suiteSymbol.Defs);
        PreSessionAction           = sessionInitializerOpt;
        PostSessionAction          = sessionFinalizerOpt;
      }
    }

    private GetDashboardVisibleParameters(defs : ImmutableArray[Def]) : List[string]
    {
      def isDashboardVisible(symbol : TypedDeclarationSymbol) : bool
      {
        | x is FormalParameterSymbol => x.CustomAttributes.Any(a => a is PredefinedAttribites.DashboardVisibleSymbol)
        | x is FieldSymbol           => x.IsIsDashboardVisibleEvaluated && x.IsDashboardVisible
        | _ => false
      }

      def result = List();
      foreach (d when isDashboardVisible(d.Symbol) in defs)
        result.Add(d.Symbol.Name);

      if (result.Count == 0) null else result
    }

    private GetSuiteScenarioList(statements : ImmutableArray[SuiteStatement], scenarioTrigger : IScenarioTrigger) : array[string]
    {
      GetScenarioList(statements.OfType.[Tdl.SuiteStatement.CallScenario]().Select(c => c.Reference), scenarioTrigger)
    }

    private GetScenarioList(scenarios : Seq[ScenarioSymbol], scenarioTrigger : IScenarioTrigger) : array[string]
    {
      def names = List();
      foreach (scenario in scenarios)
      {
        when (scenarioTrigger.IsTriggered(scenario))
          names.Add(scenario.Name);
      }
      names.ToArray()
    }
  } // module
} // namespace
