using DotNet;

using JsonDal;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Utility.Pair;

using Newtonsoft.Json;

using Nitra;
using Nitra.BackEnd.Dnlib;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using dnlib.DotNet;

using QuickType;
using Utils;

using System;
using System.Globalization;
using System.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;

using Tdl;
using Tdl2Json.ExceptionHelper;

namespace Tdl2Json
{
  public delegate TransfomationFunc(context : TransformationContext) : void;
  public delegate MessageHandler(text : string, importance : MessageImportance) : void;

  public enum MessageImportance
  {
    | Low
    | High
  }

  public module JsonGenerator
  {
    static JsonVersion : int = 7;
    public static DefaulteTimeout : TimeSpan = TimeSpan.FromMinutes(15);
    public IsExperimental = ThisAssembly.BranchName != "master";

    public event OnMessage : MessageHandler;

    public Generate(
      [NotNullOrEmpty] workingDirectory            : string,
      [NotNull]        sourceFiles                 : array[string],
      [NotNull]        references                  : array[string],
                       deploymentScriptHeader      : string,
               mutable deploymentToolPath          : string,
                       isMethodTypingEnabled       : bool,
                       output                      : Lazy[TextWriter],
                       transformatorOutput         : string,
                       transformatorOpt            : TransfomationFunc,
                       isTestMode                  : bool,
                       booleanMarshalMode          : BooleanMarshalMode,
                       jsonSchemaType              : string,
                       diffFile                    : string,
                       repositoryRoot              : string,
                       excludeTriggerPathScenarios : bool,
                       isSampleGeneration          : bool
      ) : TransformationContext
    {
      BooleanLiterals.Setup(booleanMarshalMode);

      def mode =
        match (isTestMode)
        {
          | true                             => CompilerMode.Test
          | _  when transformatorOpt != null => CompilerMode.Transform
          | _                                => CompilerMode.Compile
        };
      def absolutePaths = sourceFiles.Map(f => if(Path.IsPathRooted(f)) f else Path.Combine(workingDirectory, f));

      def CheckFilesExists(files, messageformatter : string -> string)
      {
        def notFoundFiles = files.Where(f => !File.Exists(f)).ToList();
        when (notFoundFiles.Any())
        {
          def messages = notFoundFiles.Select(messageformatter).ToArray();
          throw ConfigurationException(string.Join("\r\n", messages));
        }
      }

      CheckFilesExists(absolutePaths, m => $"File not found: $m");

      def context = Compile(workingDirectory, absolutePaths, references, isMethodTypingEnabled, mode, transformatorOutput);
      unless (context.Messages.HasErrors)
      {
        if (mode == CompilerMode.Transform)
          transformatorOpt(context);
        else
        {
          when (string.IsNullOrEmpty(deploymentToolPath))
            deploymentToolPath = <#.\KL.Autotests.Deployer.exe#>;

          GenerateJson(context, output, deploymentScriptHeader, deploymentToolPath, jsonSchemaType, diffFile, repositoryRoot,
            excludeTriggerPathScenarios, isSampleGeneration);
        }
      }

      context
    }

    private Compile(directory : string, files : array[string], refs : array[string], isMethodTypingEnabled : bool, mode : CompilerMode,
      transformatorOutput : string) : TransformationContext
    {
      TdlTypingSettings.IsMethodTypingEnabled = isMethodTypingEnabled;

      def commentBag     = if (mode == CompilerMode.Compile) null else CommentBag();
      def solution       = FsSolution();
      def project        = FsProject(solution,
                                     directory,
                                     files.Map(FsFileWithId(_, TdlLang.Instance, commentBag)),
                                     refs.Select(FileLibReference).ToArray());
      def stopwatch      = Stopwatch.StartNew();
      def projectSupport = ProjectSupport(testMode=true);
      ReportMessage("Loading types from referenced assemblies...");
      def data           = projectSupport.RefreshReferences(CancellationToken.None, project);
      ReportElapsedTime(stopwatch);

      ReportMessage("Parsing TDLs...");
      project.Data       = data;
      def files          = project.Files.Select(_.GetEvalPropertiesData()).ToImmutableArray();
      ReportElapsedTime(stopwatch);

      ReportMessage("Semantic analysis...");
      projectSupport.RefreshProject(CancellationToken.None, files, data);
      ReportElapsedTime(stopwatch);

      def messages = CompilerMessageBag(project.CompilerMessages :> CompilerMessageList);

      foreach (file when file.HasCompilerMessage in files)
        _ = messages.AddRange(file.GetCompilerMessage());

      foreach (file in project.Files)
        _ = messages.AddRange(file.GetCompilerMessages());

      def tdlProjectData = data :> TdlProjectData;
      def evalContext    = tdlProjectData.Context :> TdlDependentPropertyEvalContext;
      TransformationContext(tdlProjectData.RootNamespace, commentBag, messages, evalContext.InitialDeployment, evalContext.FinalDeployment,
        evalContext.ExportDeployments, tdlProjectData.ExternalSymbolTable, transformatorOutput)
    }

    internal ReportMessage(msg : string, importance : MessageImportance = MessageImportance.High) : void
    {
      OnMessage?.Invoke(msg, importance);
    }

    private ReportElapsedTime(stopwatch : Stopwatch) : void
    {
      ReportMessage($"Elapsed time: $(stopwatch.Elapsed)");
      stopwatch.Restart();
    }

    private GenerateJson(context : TransformationContext, output : Lazy[TextWriter], deploymentScriptHeader : string, deploymentToolPath : string,
      mutable jsonSchemaType : string, diffFile : string, repositoryRoot : string, excludeTriggerPathScenarios : bool, isSampleGeneration : bool) : void
    {
      def stopwatch = Stopwatch.StartNew();
      JsonGenerator.ReportMessage("Generating JSON...");

      when (string.IsNullOrEmpty(jsonSchemaType))
        jsonSchemaType = if (IsExperimental) "dev" else "prod";

      def preSessionActionCompiler  = SessionActionCompiler(deploymentScriptHeader, deploymentToolPath);
      def postSessionActionCompiler = SessionActionCompiler(deploymentScriptHeader, deploymentToolPath);
      def deploymentCompiler        = DeploymentCompiler(deploymentScriptHeader, deploymentToolPath);
      def symbols                   = context.RootNamespace.MemberTable.GetAllSymbols().ToList();

      def scenarioTrigger =
        if (excludeTriggerPathScenarios)
          ExcludeTriggerPathScenarioTrigger.Instance
        else if (!string.IsNullOrEmpty(diffFile) && !string.IsNullOrEmpty(repositoryRoot))
        {
          def diffFileTrigger = DiffFileScenarioTrigger(repositoryRoot);
          foreach (scenario is ScenarioSymbol in symbols)
            diffFileTrigger.AddScenario(scenario);
          using (reader = StreamReader(diffFile))
            diffFileTrigger.LoadDiff(reader, diffFile);
          _ = context.Messages.AddRange(diffFileTrigger.Messages);
          diffFileTrigger
        }
        else
          DefaultScenarioTrigger.Instance;

      def platforms      = SortedDictionary();
      def products       = SortedDictionary();
      def entities       = SortedDictionary();
      def suites         = SortedDictionary();
      def suiteGroups    = SortedDictionary();
      def scenarios      = SortedDictionary();
      def vmCapabilities = SortedDictionary();

      foreach (s is PlatformSymbol in symbols)
        platforms.AddEx(s.Name, GeneratePlatform(s), "platforms");

      def platformNameSet = HashSet(platforms.Keys, StringComparer.InvariantCultureIgnoreCase);
      def barrierCompiler = BarrierCompiler();
      def multiMachineIds = PrepareMultiMachineIds(barrierCompiler, symbols);

      foreach (symbol in symbols)
      {
        try
          match (symbol)
          {
            | ProductSymbol         as s => products .AddEx(s.Name, GenerateProduct(s, platformNameSet), "products")
            | EntitySymbol          as s => entities .AddEx(s.Name, GenerateEntity(s), "entities")
            | Suite.DefSymbol       as s => suites   .AddEx(s.Name, GenerateSuite(s, scenarioTrigger,                      preSessionActionCompiler, postSessionActionCompiler), "suites")
            | Suite.GeneratorSymbol as s => GenerateSuiteGenerator             (s, suites, suiteGroups, scenarioTrigger, preSessionActionCompiler, postSessionActionCompiler)
            | Suite.ListSymbol      as s => GenerateSuiteGroup(s, suiteGroups)
            | ScenarioSymbol        as s when scenarioTrigger.IsTriggered(s) =>
              GenerateScenario(s, context.InitialDeployment, context.FinalDeployment, deploymentCompiler, scenarioTrigger, scenarios, barrierCompiler, multiMachineIds.GetNullable(s))

            | VmCapabilitySymbol   as s when !(s.Value is Tdl.Expr.NotSet) =>
              def value = s.Value.ToObject();
              vmCapabilities.AddEx(s.Name, value, "vmCapabilities");

            | _ => ()
          }
        catch
        {
          | e is Exception =>
            throw InvalidOperationException($"Failed to generate code for '$symbol' symbol.", e)
        }
      }

      FinalizeBarriers(barrierCompiler, scenarios.Values);

      foreach (symbol in context.ExportDeployments)
        deploymentCompiler.CompileForExport(symbol);

      def defaultValues = SortedDictionary();
      when (vmCapabilities.Count > 0)
        defaultValues.AddEx("Capabilities", vmCapabilities, "defaultValues");

      foreach (f is FieldSymbol in context.ExternalSymbols.GetAllSymbols())
      {
        when (f.Value is VSome(v))
        {
          def value = v.ToObject();
          defaultValues.AddEx(f.Name, value, "defaultValues");
        }
      }

      unless (isSampleGeneration)
      {
        def version             = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;
        def versionPropertyName = "$TDL Compiler Version$";
        defaultValues.AddEx(versionPropertyName, version.ToString(), "defaultValues");
        def versionPropertyName = "$TDL Compilation Local Time$";
        defaultValues.AddEx(versionPropertyName, DateTime.Now, "defaultValues");
      }

      def config = Root() <-
      {
        Version            = JsonVersion;
        Schema             = $<#http://auto-reports.avp.ru/starter-schema/v$JsonVersion/$jsonSchemaType/schema.json#>;
        Deployments        = deploymentCompiler.GetResult();
        Products           = products;
        Platforms          = platforms;
        Suites             = suites;
        TestScenarios      = scenarios;
        SuiteGroups        = if (suiteGroups.Count == 0) null else suiteGroups;
        TestEntities       = entities;
        DefaultValues      = if (defaultValues.Count == 0) null else defaultValues;
        PreSessionActions  = preSessionActionCompiler.Compile();
        PostSessionActions = postSessionActionCompiler.Compile();
      };

      ReportElapsedTime(stopwatch);

      ReportMessage("Writing output file...");
      def settings = ConverterSettings.Settings <- Formatting = Formatting.Indented;
      def serializer = JsonSerializer.Create(settings);
      serializer.Serialize(output.Value, config);
      output.Value.Flush();

      ReportElapsedTime(stopwatch);
    }

    private PrepareMultiMachineIds(barrierCompiler : BarrierCompiler, symbols : List[DeclarationSymbol]) : Dictionary[ScenarioSymbol, Guid]
    {
      def multiMachineIdMap = Dictionary();

      foreach (Tdl.Scenario.SetSymbol(IsIsMultiMachineEvaluated=true, IsMultiMachine=true) as set in symbols)
      {
        def selfId          = set.Id;
        def scenarios       = set.AllScenarios.Where(x => x.Id != selfId).ToArray();
        foreach (scenario in scenarios)
          multiMachineIdMap[scenario] = barrierCompiler.GetMultiMachineId(set).GetValueOrDefault();
      }

      multiMachineIdMap
    }

    private GeneratePlatform(platformSymbol : PlatformSymbol) : PlatformValue
    {
      | Platform.DefSymbol        => PlatformValue() <- { Platform    = Platform() }
      | Platform.SetSymbol as Set => PlatformValue() <- { StringArray = Set.Platforms.Select(_.Name).ToArray(); }
      | _                         => ThrowNotSupportedSymbol(platformSymbol)
    }

    private MakeSuiteDefs(defs : Seq[Def], defaults : ImmutableArray[FormalParameterSymbol], variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : Hashtable[string, object]  * SortedDictionary[string, object]
    {
      def (defs2, vmCapabilities) = CollectDefs(defs, variables);
      foreach (d when !defs2.ContainsKey(d.Name) in defaults)
        defs2.AddEx(d.Name, Tdl.Expr.NotSetValue, "defs2");
      (defs2, vmCapabilities)
    }

    private CollectDefs(defs : Seq[Def], variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : Hashtable[string, object] * SortedDictionary[string, object]
    {
      def vmCapabilities = SortedDictionary();
      def result = Hashtable();
      foreach(@def in defs)
      {
        def name = @def.Symbol.Name;
        def value = @def.Expr.ToObject(variables=variables);
        if (@def.Symbol is VmCapabilitySymbol)
          vmCapabilities.AddEx(name, value, "vmCapabilities");
        else
          result.AddEx(name, value, "result");
      }
      (result, vmCapabilities)
    }

    private GenerateProduct(productSymbol : ProductSymbol, platformNameSet : HashSet[string]) : ProductValue
    {
      match (productSymbol)
      {
        | Product.DefSymbol as Def =>
          def isPlatforms(x : Def) : bool
          {
            x.Symbol.Name.Equals("Platforms", StringComparison.CurrentCultureIgnoreCase)
          }
          def (parameters, vmCapabilities) = CollectDefs(Def.Defs.Where(x => !isPlatforms(x)));
          def useAsFixedParameter(name : string) : string
          {
            mutable value;
            if (parameters.TryGetValue(name, out value))
            {
              _ = parameters.Remove(name);
              value :> string
            }
            else
              null
          }
          def name = useAsFixedParameter("Name");
          parameters.AddEx("Name", name, "parameters");
          def expr = Def.Defs.FirstOrDefault(isPlatforms);
          def platforms =
            if (expr : object == null)
              null
            else
            {
              def platforms = expr.Expr.GetExprList().Select(_.ToString()).ToArray();
              if (platformNameSet.SetEquals(platforms))
                null // ignore if all platforms included
              else
                platforms.OrderBy(x => x).ToArray()
            };
          ProductValue() <-
          {
            Product = Product() <- {
              Name              = name;
              BranchName        = useAsFixedParameter("ReleaseName") ?? useAsFixedParameter("BranchName"); //
              Version           = useAsFixedParameter("Version");
              DumpServerProduct = useAsFixedParameter("DumpServerProduct");
              Parameters        = parameters;
              Platforms         = platforms;
              Capabilities      = if (vmCapabilities.Count > 0) vmCapabilities else null;
            }
          }
        | Product.SetSymbol as Set => ProductValue() <- { StringArray = Set.AllProducts.Select(p => p.Name).ToArray(); }
        | _ => ThrowNotSupportedSymbol(productSymbol)
      }
    }

    private GetAssemblyAndMethodName(expr : Tdl.Expr, variables : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr] = null) : string * string
    {
      when (expr is Reference(Symbol=VarSymbol as v))
        return GetAssemblyAndMethodName(variables[v], variables);

      def (typeSymbolOpt, methodSymbol) =
        match (expr)
        {
          | Reference(Symbol=Member.MethodSymbol as m) => (null, m)
          | MemberAccess(Expr=MemberAccess(Symbol=GenericTypeSymbol as t), Symbol=Member.MethodSymbol as m)
          | MemberAccess(Expr=Reference   (Symbol=GenericTypeSymbol as t), Symbol=Member.MethodSymbol as m) => (t, m)
          | _ => assert(false, $"Unsupported method reference format '$expr' ($(expr.GetType().FullName))");
        };

      def decl         = methodSymbol.GetDeclarationsOfType.[ExternalMethodDeclaration]();
      def method       = decl.First().Method;
      def typeSymbol   = typeSymbolOpt :> SymbolBase;
      def type         = if (typeSymbol == null) method.DeclaringType
                         else typeSymbol.GetDeclarationsOfType.[ExternalTopTypeDeclaration.[TopClassSymbol]]().First().TypeDef;
      def assemblyName = type.DefinitionAssembly.Name + ".dll";
      def methodName   = type.FullName + "." + method.Name;

      (assemblyName, methodName)
    }

    private SplitScenarioDefs(defs : ImmutableArray[Def], variables : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : Hashtable[string, Tdl.Expr] * SortedDictionary[string, object]
    {
      def defTable       = Hashtable();
      def vmCapabilities = SortedDictionary();
      foreach (d in defs)
      {
        def key = d.Symbol.Name;
        if (d.Symbol is VmCapabilitySymbol)
        {
          def value = d.Expr.ToObject(variables=variables);
          vmCapabilities.AddEx(key, value, "vmCapabilities");
        }
        else
          defTable.AddEx(key, d.Expr, "defs");
      }
      (defTable, vmCapabilities)
    }

    private GenerateTestGroup(index : uint, allDefs : ImmutableArray[Def], actions : ImmutableArray[ScenarioAction],
      deployment : DeploymentSymbol, environments : Seq[Tdl.Environment],
      filter : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr],
      initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol, compiler : DeploymentCompiler,
      barrierCompiler : BarrierCompiler, multiMachineIdOpt : Guid?) : TestGroup
    {
      def (defs, vmCapabilities) = SplitScenarioDefs(allDefs, dic);

      def multiMachineId =
        match (defs.Get("MultiMachineId"))
        {
          | Some(expr) => barrierCompiler.GetMultiMachineId(expr, dic)
          | None => multiMachineIdOpt
        };

      def getString(name : string) : string
      {
        def getValue(expr : Tdl.Expr) : string
        {
          | String as s => s.Value
          | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
          | Reference(Symbol=FieldSymbol(DeclaredIn=ExternalSymbol) as fld) => $"#($(fld.Name))"
          | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getBool(name : string) : bool?
      {
        def getValue(expr : Tdl.Expr) : bool?
        {
              | Tdl.Expr.True  => Nullable(true)
              | Tdl.Expr.False => Nullable(false)
              | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
              | _              => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
        }
        defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getLong(name : string) : long?
      {
          def getValue(expr : Tdl.Expr) : long?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getInt(name : string) : int?
      {
          def getValue(expr : Tdl.Expr) : int?
          {
            | Integer as s => s.Value
            | Reference(Symbol=VarSymbol as v) => getValue(dic[v])
            | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
          }
          defs.Get(name).Map(getValue).WithDefault(null);
      }
      def getGuid(name : string) : Guid?
      {
        def str = getString(name);
        if (string.IsNullOrWhiteSpace(str))
          null
        else
          Guid.Parse(str)
      }

      mutable uniqueId = getGuid("UniqueId");
      when (index > 0)
        uniqueId = Api.IncrementGuid(uniqueId.Value, index);
      def artifactsCollectionTimeout = getString("ArtifactsCollectionTimeout");
      def assignedParams = allDefs.FilterToArray(d => d.Symbol.IsDeclaredInOptEvaluated && d.Symbol.DeclaredInOpt.HasValue && d.Symbol.DeclaredInOpt.Value is DeploymentSymbol);

      def testGroup =
        TestGroup() <-
        {
          Deployments             = GetTestGroupDeployments(initialDeployment, finalDeployment, deployment, compiler, assignedParams, dic);
          Environments            = environments.MapToArray(env => EnvironmentElement() <- { Platforms= array[env.Platform.Name]; Products=array[env.Product.Name]; });
          TestMethod              = MakeTestMethod(actions, artifactsCollectionTimeout, barrierCompiler, multiMachineId, dic);
          Area                    = getString("Area");
          ExternalAutotestId      = getInt   ("ExternalAutotestId");
          LocalTestBinariesFolder = getString("LocalTestBinariesFolder");
          NeedUnsignedAgent       = getBool  ("NeedUnsignedAgent");
          RequireInternet         = getBool  ("RequireInternet");
          MayDropNetwork          = getBool  ("MayDropNetwork");
          RerunCountOnTestFailure = getLong  ("RerunCountOnTestFailure");
          RerunCountOnTestSuccess = getLong  ("RerunCountOnTestSuccess");
          Responsible             = getString("Responsible");
          RevertAgentAfter        = getBool  ("RevertAgentAfter") ?? true;
          RevertAgentBefore       = getBool  ("RevertAgentBefore");
          TfsId                   = getLong  ("TfsId");
          Timeout                 = getString("Timeout");
          UniqueId                = uniqueId;
          ProductGroupName        = getString("ProductGroupName");
          FilterExpression        = GenerateScenarioFilter(filter, dic);
          MultiMachineId          = multiMachineId;
          Capabilities            = if (vmCapabilities.Count > 0) vmCapabilities else null;
        };

      testGroup
    }

    private MakeBarrier(barrierCompiler : BarrierCompiler, multiMachineId : Guid, b : ScenarioAction.Barrier) : WaitForBarrierTestStep
    {
      WaitForBarrierTestStep() <-
      {
        WaitForBarrier =
          WaitForBarrierTestStep.Data() <-
          {
            Id      = barrierCompiler.UseBarrier(multiMachineId, b.barrier.Name);
            Timeout = TimeSpan.Parse(b.barrier.Timeout.Value);
          }
      }
    }

    private MakeBarrier(barrierCompiler : BarrierCompiler, multiMachineId : Guid, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr], bg : ScenarioAction.BarrierGenerator) : WaitForBarrierTestStep
    {
      WaitForBarrierTestStep() <-
      {
        WaitForBarrier =
          WaitForBarrierTestStep.Data() <-
          {
            Id      = barrierCompiler.UseBarrier(multiMachineId, dic, bg);
            Timeout = bg.Timeout;
          }
      }
    }

    private FinalizeBarriers(barrierCompiler : BarrierCompiler, scenarios : Seq[TestCase]) : void
    {
      def walkMethod(_ : object)
      {
        | m is WaitForBarrierTestStep => m.WaitForBarrier.Count = barrierCompiler.GetBarrierCount(m.WaitForBarrier.Id)
        | m is TestMethodSequence     =>
          foreach (x in m.TestSequence)
            walkMethod(x);

        | _ => ()
      }

      foreach (s in scenarios)
        walkMethod(s.TestGroup?.TestMethod);
    }

    private GenerateScenario(scenarioSymbol : ScenarioSymbol, initialDeployment : DeploymentSymbol, finalDeployment : DeploymentSymbol,
      compiler : DeploymentCompiler, scenarioTrigger : IScenarioTrigger, scenarios : IDictionary[string, TestCase],
      barrierCompiler : BarrierCompiler, multiMachineIdOpt : Guid?) : void
    {
      def addTestCase(name, testGroup)
      {
        scenarios.AddEx(name, TestCase() <- { TestGroup = testGroup; }, "scenarios");
      }

      match (scenarioSymbol)
      {
        | Tdl.Scenario.SetSymbol as s => addTestCase(scenarioSymbol.Name, TestGroup() <- { TestScenarios = GetScenarioList(s.Scenarios, scenarioTrigger) });
        | Tdl.Scenario.DefSymbol as r =>
          def testGroup = GenerateTestGroup(0, r.Defs, r.Actions, r.Deployment, r.Environments, r.Filter :> DotNet.ExprBase,
            ImmutableDictionary.Empty, initialDeployment, finalDeployment, compiler, barrierCompiler, multiMachineIdOpt);
          addTestCase(scenarioSymbol.Name, testGroup);

        | Tdl.Scenario.GeneratorSymbol as g =>
          def names = List();
          foreach (dic in Api.SubstituteVariables(g.Froms, 0))
          {
            def deployment = Api.TryResolveVar(dic, g.Deployment) : DeploymentSymbol;
            def environments = array[Tdl.Environment(
              Api.TryResolveVar(dic, g.Platform) : PlatformSymbol,
              Api.TryResolveVar(dic, g.Product) : ProductSymbol)];
            def testGroup = GenerateTestGroup(names.Count :> uint, g.Defs, g.Actions, deployment, environments, g.Filter :> DotNet.ExprBase,
              dic, initialDeployment, finalDeployment, compiler, barrierCompiler, multiMachineIdOpt);
            def name = scenarioSymbol.Name + "-" + (names.Count + 1);
            names.Add(name);
            addTestCase(name, testGroup);
          }
          def testGroup = TestGroup() <- { TestScenarios = names.ToArray() };
          addTestCase(scenarioSymbol.Name, testGroup);

        | _ => _ = ThrowNotSupportedSymbol(scenarioSymbol)
      }
    }

    private MakeTestMethod(actions : ImmutableArray[ScenarioAction], artifactsCollectionTimeout : string, barrierCompiler : BarrierCompiler,
      multiMachineId : Guid?, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : TestMethod
    {
      def makeMethodAction(method : ScenarioAction.Method) : TestMethodQualifier
      {
        _ = method.Expr;
        def (assemblyName, methodName) = GetAssemblyAndMethodName(method.Expr, dic);
        TestMethodQualifier() <-
        {
          AssemblyName               = assemblyName;
          MethodName                 = methodName;
          MaxRebootsCount            = method.MaxRebootsCountOpt.ExprToInt(dic);
          ContinueOnError            = method.ContinueOnErrorOpt.ToNullable();
          ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          LocalTestBinariesFolder    = method.BinariesFolderOpt.ExprToString(dic);
        }
      }
      def makeScriptAction(c : ScenarioAction.Script) : UnixScriptRunner
      {
          def testScriptArgs = string.Join(" ", c.Arguments.Select(a => a.ExprToString(dic).ToLiteral()));
          def env = c.Defs.Select(d => (d.Symbol.Name, d.Expr.ToObject(values=null, variables=dic))).ToDictionary();
          UnixScriptRunner() <-
          {
            TestScriptName             = c.Name.ExprToString(dic);
            TestScriptArgs             = testScriptArgs;
            Environment                = env;
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          }
      }
      def makeGTestAction(c : ScenarioAction.GTest) : GTestProgram
      {
          def testScriptArgs = c.Arguments.MapToArray(a => a.ExprToString(dic));
          GTestProgram() <-
          {
            ProgramName                = c.Name.ExprToString(dic);
            Arguments                  = testScriptArgs;
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          }
      }
      def makeXCodeAction(c : ScenarioAction.XCode) : XCode
      {
          XCode() <-
          {
            XCodeTestContainer         = c.Container.ExprToString(dic);
            XcodePath                  = c.XcodePath.ExprToString(dic);
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          }
      }
      def makeVsTestAction(c : ScenarioAction.VsTest) : VsTest
      {
          VsTest() <-
          {
            VsTestAssemblyName         = c.Container.ExprToString(dic);
            VsTestRunCmdLine           = c.VsTestRunCmdLineOpt.ExprToString(dic);
            TestCaseFilter             = c.FilterOpt.ExprToString(dic);
            Platform                   = c.VsTestPlatformOpt.ExprToString(dic);
            Framework                  = c.VsTestFrameworkOpt.ExprToString(dic);
            AdditionalOptions          = c.VsTestAdditionalOptionsOpt.ExprToString(dic);
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
            ArtifactsCollectionTimeout = artifactsCollectionTimeout;
          }
      }
      def makeAndroidJavaAction(c : ScenarioAction.Apk) : AndroidJava
      {
          AndroidJava() <-
          {
            AndroidTestContainer       = c.Name.ExprToString(dic);
            TestFilter                 = c.FilterOpt.ExprToString(dic);
            TestRunnerPath             = c.RunnerPath.ExprToString(dic);
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
          }
      }
      def makeMarathonAction(c : ScenarioAction.Marathon) : Marathon
      {
          Marathon() <-
          {
            AndroidTestContainer       = c.TestContainerApk.ExprToString(dic);
            AndroidTestContainer       = c.AppApk.ExprToString(dic);
            MarathonTestRunnerPath     = c.RunnerPath.ExprToString(dic);
            TestFilter                 = c.Filter.ExprToString(dic);
            LocalTestBinariesFolder    = c.BinariesFolder.ExprToString(dic);
            MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
          }
      }
      def makeConfigAction(c : ScenarioAction.Config) : TestBot
      {
        TestBot() <-
        {
          TestConfigName             = c.path.ExprToString(dic);
          MaxRebootsCount            = c.MaxRebootsCountOpt.ExprToInt(dic);
          ArtifactsCollectionTimeout = artifactsCollectionTimeout;
        }
      }
      def makeAction(action : ScenarioAction) : TestSequenceItem
      {
        | Reboot        as r      => MakeRebootTestStep(r)
        | Method        as method => makeMethodAction(method)
        | WaitForReboot as wbr =>
          WaitForRebootTestStep() <-
          {
            WaitForReboot =
              WaitForRebootTestStep.Data() <-
              {
                RebootTimeout   = if (string.IsNullOrEmpty(wbr.TimeSpan)) "00:05:00" else wbr.TimeSpan;
                MaxRebootsCount = wbr.MaxRebootsCountOpt.ExprToInt();
              };
          }
        | BarrierGenerator as bg => MakeBarrier(barrierCompiler, multiMachineId.Value, dic, bg)
        | Barrier as barrier => MakeBarrier(barrierCompiler, multiMachineId.Value, barrier)
        | Script as s        => makeScriptAction(s)
        | Config as c        => makeConfigAction(c)
        | GTest  as g        => makeGTestAction(g)
        | XCode  as x        => makeXCodeAction(x)
        | VsTest as x        => makeVsTestAction(x)
        | Apk    as a        => makeAndroidJavaAction(a)
        | Marathon as m      => makeMarathonAction(m)
        | Runner as r        => MakeRunnerTestStep(r, dic)
        | Login  as login    => LoginTestStep() <-
          {
            Login = LoginTestStep.Data() <-
            {
              User = login.User.ExprToString(dic);
              Password = login.Password.ExprToString(dic);
            }
          }

        | Logoff             => LogoffTestStep() <- { Logoff = LogoffTestStep.Data() }
        | LockWorkstation    => LockWorkstationTestStep() <- { LockWorkstation = LockWorkstationTestStep.Data() }
        | _                  => assert(false, "Unsupported ScenarioAction: " + action)
      }

      if (actions.Length == 1)
        makeAction(actions[0]) :> TestMethod
      else
        TestMethodSequence() <-
        {
          TestSequence               = actions.Select(makeAction).ToArray();
          ArtifactsCollectionTimeout = artifactsCollectionTimeout;
        }
    }

    private MakeRebootTestStep(reboot : ScenarioAction.Reboot) : RebootTestStep
    {
      RebootTestStep() <-
      {
        ForceReboot = RebootTestStep.Data() <-
        {
          Mode =
            match (reboot.Mode)
            {
              | Tdl.RebootMode.Default       => null
              | Tdl.RebootMode.EnterSafeMode => QuickType.RebootMode.EnterSafeMode
              | Tdl.RebootMode.ExitSafeMode  => QuickType.RebootMode.ExitSafeMode
            }
        }
      }
    }

    private MakeRunnerTestStep(runner : ScenarioAction.Runner, variables : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : RunnerTestStep
    {
      def step = RunnerTestStep();

      def arguments = runner.Arguments.ToDictionary();
      foreach (p in runner.Symbol.Parameters)
      {
        when (p.HasDefault() && !arguments.ContainsKey(p.Name))
          arguments[p.Name] = ConvertDefaultValue(p.Default);
      }

      foreach (d in runner.Symbol.Defs)
      {
        match (d.Expr.Calc(values=arguments, variables=variables, getPropertyValue=(_) => ("unsupported expression", ResultKind.Error)))
        {
          | (value, ResultKind.Value) => step[d.Name] = value
          | (data, ResultKind.Error) => throw NotSupportedException($"$data: $d.Expr")
          | (_, kind) => throw NotSupportedException($"unsupported expression ($kind): $(d.Name) = $(d.Expr)")
        }
      }
      step
    }

    private GetTestGroupDeployments(initialDeployment  : DeploymentSymbol,
                                    finalDeployment    : DeploymentSymbol,
                                    scenarioDeployment : DeploymentSymbol,
                                    compiler           : DeploymentCompiler,
                                    assignedParams     : array[Def],
                                    dic                : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : array[TestGroupDeployment]
    {
      mutable deployments = [];
      def scope = HashSet(StringComparer.OrdinalIgnoreCase);

      def addDeployment(deployment : DeploymentSymbol)
      {
        when (deployment != null && !NList.Contains(deployments, deployment))
        {
          deployments ::= deployment;

          foreach (symbol in deployment.AggregateParametersScope.GetAllSymbols())
            _ = scope.Add(symbol.Name);
        }
      }

      addDeployment(finalDeployment);
      addDeployment(scenarioDeployment);
      addDeployment(initialDeployment);

      def sortedAssignedParams = assignedParams.Where(x => scope.Contains(x.Symbol.Name)).Select(x => (x.Symbol.Name, x.Expr.ToObject(null, dic))).OrderBy((n, _) => n).NToList();
      def result               = compiler.Compile(deployments, sortedAssignedParams);
      compiler.GetCompositeDeployment(scenarioDeployment.Name, result)
    }

    private GenerateEntity(symbol : EntitySymbol) : TestEntity
    {
      def (parameters, _) = CollectDefs(symbol.Defs);
      TestEntity() <-
      {
        BranchName = parameters["BranchName"].ToString();
        Name       = parameters["Name"      ].ToString();
        Type       = parameters["Type"      ].ToString();
        Version    = parameters["Version"   ].ToString();
      }
    }

    private GenerateScenarioFilter() : string
    {
      null
    }

    private GenerateScenarioFilter(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      def result = GenerateScenarioFilterImpl(expr, dic);
      result
    }

    private GenerateTdlExpr(expr : Tdl.Expr, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | NotSet                        => "\"" + Tdl.Expr.NotSetValue + "\""
        | Error                         => GenerateScenarioFilter()
        | String(null)                  => "null"
        | String(s)                     => $<#@"$(s.Replace("\"", "\"\""))"#>
        | True                          => "true"
        | False                         => "false"
        | Real(num)                     => num.ToString(CultureInfo.InvariantCulture)
        | Integer(num)                  => num.ToString(CultureInfo.InvariantCulture)
        | Reference(symbol)             => GenerateBySymbol(symbol, dic)
        | MemberAccess(expr, member, _) => GenerateTdlExpr(expr, dic) + "." + member.InitialName
        | Tuple(items, _) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#(..$args)#>

        | List(items, type) =>
          def args = items.Map(GenerateTdlExpr(_, dic));
          $<#new $(type.FullName)[] { ..$args }#>

        | ObjectInitializer(properties) =>
          def props = properties.Map((n, v) => $"$n = $(GenerateTdlExpr(v, dic))");
          $<#new { ..$props }#>
      }
    }

    private ConvertDefaultValue(value : DotNet.DefaultValue) : Tdl.Expr
    {
      | Null                  => Tdl.Expr.NotSet()
      | String(null)          => Tdl.Expr.String(null)
      | String(s)             => Tdl.Expr.String(s)
      | Bool(true)            => Tdl.Expr.True()
      | Bool(false)           => Tdl.Expr.False()
      | Number(num, false, false) => Tdl.Expr.Integer(unchecked(num :> int))
      | Number(num, true, false)  => Tdl.Expr.Real(unchecked(num :> uint))
      | Number(num, false, true)  => Tdl.Expr.Real(unchecked(num :> long))
      | Number(num, true, true)   => Tdl.Expr.Real(num : ulong)
      | Decimal(num)          => Tdl.Expr.Real(num :> double)
      | Double(num)           => Tdl.Expr.Real(num)
      | Single(num)           => Tdl.Expr.Real(num)
      | Custom(x is Tdl.Expr) => x
      | t                     => throw NotSupportedException($"$(t.GetType().Name) is not supported in scenario parameters")
    }

    private GenerateDefaultValue(value : DotNet.DefaultValue) : string
    {
      | Null                  => "null"
      | String(null)          => "null"
      | String(s)             => $<#@"$(s.Replace("\"", "\"\""))"#>
      | Bool(true)            => "true"
      | Bool(false)           => "false"
      | Number(num, true, _)  => num.ToString(CultureInfo.InvariantCulture)
      | Number(num, false, _) => unchecked(num :> long).ToString(CultureInfo.InvariantCulture)
      | Decimal(num)          => num.ToString(CultureInfo.InvariantCulture)
      | Double(num)           => num.ToString(CultureInfo.InvariantCulture)
      | Single(num)           => num.ToString(CultureInfo.InvariantCulture)
      | t                     => throw NotSupportedException($"$(t.GetType().Name) is not supported in scenario parameters")
    }

    private GenerateBySymbol(symbol : DeclarationSymbol, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      mutable tdlExpr;
      match (symbol)
      {
        | FieldSymbol as fld =>
          match (fld.DeclaredIn)
          {
            | ExternalSymbol =>
              def type = fld.Type.FullName;
              def name = fld.Name;
              def getValue = $<#(($type)externals["$name"])#>;
              match (type)
              {
                | "System.String" | "string" => $<#(externals.ContainsKey("$name") ? $getValue : "")#>
                | _ => getValue
              }

            | _ => GenerateScenarioFilter()
          }

        | FormalParameterSymbol as p =>
          def type =
            match (p.Type)
            {
              | SuiteTypeSymbol => "TestSuite"
              | _ => p.Type.FullName
            };

          def name = p.Name;
          def getValue =
            match (type)
            {
              | "System.Boolean" | "bool" => $<#(!System.Linq.Enumerable.Contains(new[] { "0", "false", null }, globals["$name"]?.ToString(), System.StringComparer.OrdinalIgnoreCase))#>
              | _                         => $<#(($type)globals["$name"])#>
            };

          if (p.HasDefault())
          {
            def defaultValue = GenerateDefaultValue(p.Default);
            $<#(globals.ContainsKey("$name") ? $getValue : $defaultValue)#>
          }
          else
            getValue

        | Member.MethodSymbol as m => m.Name
        | PlatformSymbol as p => $<#config.Platforms["$(p.Name)"]#>
        | ProductSymbol  as p => $<#config.Products["$(p.Name)"]#>
        | TypedDeclarationSymbol as s when dic.TryGetValue(s, out tdlExpr) => GenerateTdlExpr(tdlExpr, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    public static ToFullNameString(symbol : TypeSymbol) : string
    {
      | DotNet.TopConstructedTypeSymbol as s =>
        def fullName = AstUtils.MakeFullName(s.TypeInfo.DeclaredInOpt, s.TypeInfo.Name, s.Args);
        fullName

      | _ => GenerateScenarioFilter()
    }

    private GenerateScenarioFilterImpl(expr : DotNet.ExprBase, dic : IReadOnlyDictionary[TypedDeclarationSymbol, Tdl.Expr]) : string
    {
      match (expr)
      {
        | null => null
        | Expr.Is as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) is $(e.TypeNameType))#>
        | Expr.As as e => $<#($(GenerateScenarioFilterImpl(e.Expr1, dic)) as $(e.Type))#>
        | DotNet.IntegerLiteral
        | DotNet.RealLiteral
        | DotNet.Expr.BooleanLiteral
        | DotNet.Expr.Char
        | DotNet.Expr.String => expr.ToString().Trim()
        | Expr.Invocation as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))(..$args)#>;

        | Expr.IndexerAccess as e =>
        def args = e.Arguments.Map(GenerateScenarioFilterImpl(_, dic));
        $<#$(GenerateScenarioFilterImpl(e.Left, dic))[..$args]#>;

        | Expr.Parenthesized   as e => GenerateScenarioFilterImpl(e.Expression, dic)
        | Expr.PostDecrement (Expr1=e) with op = "++"
        | Expr.PostIncrement (Expr1=e) with op = "--"
          => $<#$(GenerateScenarioFilterImpl(e, dic))$op#>

        | Expr.PreIncrement    (Expr1=e) with op = "++"
        | Expr.PreDecrement    (Expr1=e) with op = "--"
        | Expr.BitwiseNegation (Expr1=e) with op = "~"
        | Expr.LogicalNegation (Expr1=e) with op = "!"
        | Expr.Negation        (Expr1=e) with op = "-"
          => $<#$op$(GenerateScenarioFilterImpl(e, dic))#>

        | Expr.TypeOf as e => $<#typeof($(e.Type))#>
        | Expr.GreaterThanOrEqual(Expr1=e1, Expr2=e2)  with op = ">="
        | Expr.LessThanOrEqual   (Expr1=e1, Expr2=e2)  with op = "<="
        | Expr.Less              (Expr1=e1, Expr2=e2)  with op =  "<"
        | Expr.Greater           (Expr1=e1, Expr2=e2)  with op =  ">"
        | Expr.ConditionalAnd    (Expr1=e1, Expr2=e2)  with op = "&&"
        | Expr.ConditionalOr     (Expr1=e1, Expr2=e2)  with op = "||"
        | Expr.Equal             (Expr1=e1, Expr2=e2)  with op = "=="
        | Expr.NotEqual          (Expr1=e1, Expr2=e2)  with op = "!="
        | Expr.NullCoalescing    (Expr1=e1, Expr2=e2)  with op = "??"
        | Expr.LogicalOr         (Expr1=e1, Expr2=e2)  with op = "|"
        | Expr.LogicalAnd        (Expr1=e1, Expr2=e2)  with op = "&"
        | Expr.LogicalXor        (Expr1=e1, Expr2=e2)  with op = "~"
        | Expr.ShiftLeft         (Expr1=e1, Expr2=e2)  with op = "<<"
        | Expr.ShiftRight        (Expr1=e1, Expr2=e2)  with op = ">>"
        | Expr.Sum               (Expr1=e1, Expr2=e2)  with op = "+"
        | Expr.Sub               (Expr1=e1, Expr2=e2)  with op = "-"
        | Expr.Modulus           (Expr1=e1, Expr2=e2)  with op = "%"
        | Expr.Multiply          (Expr1=e1, Expr2=e2)  with op = "*"
        | Expr.Divide            (Expr1=e1, Expr2=e2)  with op = "/"
          => $<#($(GenerateScenarioFilterImpl(e1, dic)) $op $(GenerateScenarioFilterImpl(e2, dic)))#>
        | Expr.Cast           as e => $<#(($(e.TypeName))$(GenerateScenarioFilterImpl(e.Expression, dic)))#>

        | Expr.Conditional as e =>
        def type = e.Type.FullName;
        $<#($(GenerateScenarioFilterImpl(e.Condition, dic)) ? (($type)$(GenerateScenarioFilterImpl(e.Expr1, dic))) : (($type)$(GenerateScenarioFilterImpl(e.Expr2, dic))))#>

        | Expr.Argument as a => GenerateScenarioFilterImpl(a.Expr, dic)
        | Expr.MemberAccess1 as e =>
            def member = e.Ref.Symbol;
            if (e.Expr1.Type is Tdl.SuiteTypeSymbol && member is Tdl.FieldSymbol)
              $<#(($(e.Type))globals["$(member.Name)"])#>
            else
              GenerateScenarioFilterImpl(e.Expr1, dic) + "." + member.Name

        | Expr.SimpleName as e => GenerateBySymbol(e.Ref.Symbol, dic)
        | _ => GenerateScenarioFilter()
      }
    }

    private GenerateSuiteGroup(suiteSymbol : Suite.ListSymbol, suiteGroups : IDictionary[string, SuiteGroup]) : void
    {
      def suites = List();
      foreach (symbol in suiteSymbol.AllSuites)
      {
        | s is Suite.DefSymbol       => suites.Add(s.Name)
        | s is Suite.GeneratorSymbol => suites.AddRange(suiteGroups.GetValue(s.Name, "suiteGroups").Suites)
        | _ => assert2(false, $"Invalid symbol $(symbol) in AllSymbols")
      }

      suiteGroups.AddEx(suiteSymbol.Name, SuiteGroup() <- { Suites = suites }, "suiteGroups")
    }

    private TryGenerateAction(
      actionName : string,
      gen : Suite.GeneratorSymbol,
      product : ProductSymbol,
      variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr],
      sessionActionCompiler : SessionActionCompiler
    ) : string
    {
      def sessionActionOpt = gen.Predefineds.Find(p => p.Symbol.Name == actionName);
      match (sessionActionOpt)
      {
        | Some(Def(Expr=Tdl.Expr.Reference(Symbol=TypedDeclarationSymbol as td))) with d = Api.TryResolveVarOrNull(variables, td)
        | Some(Def(Expr=Tdl.Expr.Reference(Symbol=DeploymentSymbol as d))) when d != null =>
          def resultOpt = Api.MakeDeploymentsTree(d, product, gen.Defs, gen.DefaultDefs, variables);
          when (resultOpt is VSome(tree))
            return sessionActionCompiler.GetSessionActionName(tree, variables)

        | _ => ()
      }
      null
    }

    private GenerateSuiteGenerator(
      gen                       : Suite.GeneratorSymbol,
      suites                    : IDictionary[string, TestSuite],
      suiteGroups               : IDictionary[string, SuiteGroup],
      scenarioTrigger           : IScenarioTrigger,
      preSessionActionCompiler  : SessionActionCompiler,
      postSessionActionCompiler : SessionActionCompiler
    ) : void
    {
      def nameBase = gen.Name;
      def names = List();

      foreach (dic in Api.SubstituteVariables(gen.Froms, 0))
      {
        def toString(e : Tdl.Expr) : string
        {
          | String as s => s.Value
          | _ => e.ToString()
        }
        def name                   = $<#$nameBase-..$(dic.Values; "-"; toString)#>;
        names.Add(name);
        def platform               = Api.TryResolveVar(dic, gen.Platform) : PlatformSymbol;
        def product                = Api.TryResolveVar(dic, gen.Product)  : ProductSymbol;
        def entityOpt              = if (gen.EntityOpt.HasValue) (Api.TryResolveVar(dic, gen.EntityOpt.Value) : EntitySymbol).Name else null;
        def (defs, vmCapabilities) = MakeSuiteDefs(gen.Defs, gen.DefaultDefs, dic);
        def sessionInitializer     = TryGenerateAction("SessionInitializer", gen, product, dic, preSessionActionCompiler);
        def sessionFinalizer       = TryGenerateAction("SessionFinalizer",   gen, product, dic, postSessionActionCompiler);

        def suite = TestSuite() <-
        {
          Platforms                  = array[platform.Name];
          Products                   = array[product.Name];
          TestScenarios              = GetSuiteScenarioList(gen.Statements, scenarioTrigger);
          Parameters                 = defs;
          TestEntity                 = entityOpt;
          DashboardVisibleParameters = GetDashboardVisibleParameters(gen.Type, gen.Statements);
          PreSessionAction           = sessionInitializer;
          PostSessionAction          = sessionFinalizer;
          Capabilities               = if (vmCapabilities.Count > 0) vmCapabilities else null;
        };

        suites.AddEx(name, suite, "suites");
      }

      suiteGroups.AddEx(nameBase, SuiteGroup() <- { Suites = names; }, "suiteGroups");
    }

    private GenerateSuite(suiteSymbol : Suite.DefSymbol, scenarioTrigger : IScenarioTrigger, preSessionActionCompiler : SessionActionCompiler, postSessionActionCompiler : SessionActionCompiler) : TestSuite
    {
      def (defs, vmCapabilities) = MakeSuiteDefs(suiteSymbol.Defs, suiteSymbol.DefaultDefs);
      def sessionInitializerOpt  = if (suiteSymbol.SessionInitializer is VSome(init)) preSessionActionCompiler .GetSessionActionName(init, variables=null) else null;
      def sessionFinalizerOpt    = if (suiteSymbol.SessionFinalizer   is VSome(init)) postSessionActionCompiler.GetSessionActionName(init, variables=null) else null;
      def entityOpt              = suiteSymbol.EntityOpt;
      TestSuite() <-
      {
        Platforms                  = array[suiteSymbol.Platform.Name];
        Products                   = array[suiteSymbol.Product.Name];
        TestScenarios              = GetSuiteScenarioList(suiteSymbol.Statements, scenarioTrigger);
        Parameters                 = defs;
        TestEntity                 = if (entityOpt.HasValue) entityOpt.Value.Name else null;
        DashboardVisibleParameters = GetDashboardVisibleParameters(suiteSymbol.Type, suiteSymbol.Statements);
        PreSessionAction           = sessionInitializerOpt;
        PostSessionAction          = sessionFinalizerOpt;
        Capabilities               = if (vmCapabilities.Count > 0) vmCapabilities else null;
      }
    }

    private GetDashboardVisibleParameters(type : TypeSymbol, statements : ImmutableArray[SuiteStatement]) : List[string]
    {
      def result = SortedSet();

      foreach(field is FieldSymbol when field.IsIsDashboardVisibleEvaluated && field.IsDashboardVisible in type.Scope.GetAllSymbols())
        _ = result.Add(field.Name);

      foreach (call is Tdl.SuiteStatement.CallScenario in statements)
      foreach (symbol in call.Reference.DashboardVisibleParameters)
        _ = result.Add(symbol.Name);

      if (result.Count == 0) null else result.ToList()
    }

    private GetSuiteScenarioList(statements : ImmutableArray[SuiteStatement], scenarioTrigger : IScenarioTrigger) : array[string]
    {
      GetScenarioList(statements.OfType.[Tdl.SuiteStatement.CallScenario]().Select(c => c.Reference), scenarioTrigger)
    }

    private GetScenarioList(scenarios : Seq[ScenarioSymbol], scenarioTrigger : IScenarioTrigger) : array[string]
    {
      def names = List();
      foreach (scenario in scenarios)
      {
        when (scenarioTrigger.IsTriggered(scenario))
          names.Add(scenario.Name);
      }
      names.ToArray()
    }
  } // module
} // namespace
