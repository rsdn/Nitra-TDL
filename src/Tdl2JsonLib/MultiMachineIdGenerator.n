using Tdl;
using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Tdl2Json
{
  class MultiMachineIdGenerator
  {
    static         _baseStableGuid      : Guid = Guid.Parse("{CCCCCCCC-CCCC-CCCC-CCCC-CCCCCCCCCCCC}");
    static mutable _counter             : uint;

    _idTable : Dictionary[object, Guid] = Dictionary();

    public GetId(key : object) : Guid?
    {
      if (key == null)
        null
      else
      {
        mutable id;
        unless (_idTable.TryGetValue(key, out id))
        {
          _counter++;
          id = Api.IncrementGuid(_baseStableGuid, _counter);
          _idTable.Add(key, id);
        }
        id
      }
    }

    public GetId(expr : Tdl.Expr, variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr]) : Guid?
    {
      def getKey(expr : Tdl.Expr) : object
      {
        | NotSet            => null
        | Error             => null
        | String(value)     => value
        | True              => true
        | False             => false
        | Real(value)       => value
        | Integer(value)    => value
        | Reference(symbol) =>
          when (symbol is TypedDeclarationSymbol as typedSymbol)
          {
            mutable substitutedExpr;
            when (variables : object != null && variables.TryGetValue(typedSymbol, out substitutedExpr))
              return getKey(substitutedExpr);
          }
          symbol

        | Tuple(elems, _)
        | List(elems, _) =>
          mutable acc = [expr.GetType() : object];
          for (mutable i = elems.Length - 1; i >= 0; --i)
            acc ::= getKey(elems[i]);
          acc

        | _ => throw NotSupportedException($"$expr ($(expr.GetType().Name))")
      }

      GetId(getKey(expr))
    }
  }
}
