using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;

using Tdl;

namespace Tdl2Json
{
  class DeploymentCompiler
  {
    variant SequenceItem
    {
      | Opaque      { reference : QuickType.TestGroupDeployment }
      | Transparent
        {
          Symbol    : Deployment.CodeSymbol;
          Values    : IReadOnlyDictionary[string, object];
          CallStack : list[DeploymentSymbol];
        }
    }

    private _compiledDeployments     : Dictionary[string * int, string * QuickType.Deployment] = Dictionary();
    private _deployments             : SortedDictionary[string, QuickType.Deployment]          = SortedDictionary();
    private _deploymentScriptHeader  : string;
    private _deploymentToolPath      : string;
    private mutable _emptyDeployment : QuickType.TestGroupDeployment;

    public this(deploymentScriptHeader : string, deploymentToolPath : string)
    {
      _deploymentScriptHeader = deploymentScriptHeader;
      _deploymentToolPath     = deploymentToolPath;
    }

    public GetResult() : IDictionary[string, QuickType.Deployment]
    {
      _deployments
    }

    public static GetDefaultValue(parameter : DotNet.FormalParameterSymbol) : object
    {
      match (parameter.Default)
      {
        | String    as s => s.Value
        | Bool      as b => if (b.Value) BooleanLiterals.True else BooleanLiterals.False
        | Number    as n => n.Value
        | Decimal   as d => d.Value
        | Double    as d => d.Value
        | Single    as s => s.Value
        | None           => null
        | Reference as r => "#(" + r.name + ")"
        | _              => throw NotSupportedException($"$(parameter.Default.GetType().Name) is not supported in deployment parameters")
      }
    }    

    [Memoize]
    public Compile(seq : list[DeploymentSymbol]) : array[QuickType.TestGroupDeployment]
    {
      CompileSequence(seq, Dictionary(StringComparer.OrdinalIgnoreCase))
    }

    public GetEmptyDeployment() : QuickType.TestGroupDeployment
    {
      when (_emptyDeployment == null)
      {
        def name = ProjectSupport.EmptyDeploymentName;
        _deployments.Add(name, QuickType.Deployment() <- { Type = QuickType.TypeEnum.Empty });
        _emptyDeployment = MakeDeploymentReference(name, null);
      }
      _emptyDeployment
    }

    private CompileSequence(deployments : Seq[DeploymentSymbol], rootValues : Dictionary[string, object]) : array[QuickType.TestGroupDeployment]
    {
      def walk(d : DeploymentSymbol, values : Dictionary[string, object], sequence : List[SequenceItem], mutable callStack : list[DeploymentSymbol])
      {
        callStack = d :: callStack;
        match (d)
        {
          | Deployment.EmptySymbol         => ()
          | Deployment.CodeSymbol     as s => sequence.Add(SequenceItem.Transparent(s, values, callStack))
          | DeploymentRebootSymbol    as s =>
            unless (_deployments.ContainsKey(s.Name))
              CompileReboot(s);
            sequence.Add(SequenceItem.Opaque(MakeDeploymentReference(s.Name, null)))

          | Deployment.ScriptSymbol   as s =>
            unless (_deployments.ContainsKey(s.Name))
              CompileScript(s);
            sequence.Add(SequenceItem.Opaque(MakeDeploymentReference(s.Name, values)))

          | Deployment.SetSymbol      as s =>
            foreach (d in s.Deployments)
              walk(d, values, sequence, callStack);

          | Deployment.CurryingSymbol as s =>
            foreach (p in s.Parameters)
            {
              def defaultValue = GetDefaultValue(p);
              when (defaultValue != null && !values.ContainsKey(p.Name))
              {
                unless (_deployments.ContainsKey(s.Name))
                  CompileCurring(s);
                sequence.Add(SequenceItem.Opaque(MakeDeploymentReference(s.Name, values)));
                return;
              }
            }

            def innerValues = Dictionary(values, values.Comparer);
            foreach (x in s.ParameterValues)
              innerValues[x.Symbol.Name] = x.Expr.ToObject(values);
            walk(s.BaseDeployment, innerValues, sequence, callStack);

          | Deployment.SelectSymbol   as s =>
            def parameters = s.Parameters;
            def parameterValues = array(parameters.Length);

            def bindParameters(i)
            {
              if (i < parameters.Length)
              {
                mutable value;
                if (values.TryGetValue(parameters[i].Name, out value))
                {
                  parameterValues[i] = value;
                  bindParameters(i + 1)
                }
                else false
              }
              else true
            }

            when (bindParameters(0))
            {
              foreach (c when c.SequenceEqual(parameterValues) in s.Cases with i)
              {
                foreach (d in s.Deployments[i])
                  walk(d, values, sequence, callStack);
                return;
              }
            }

            unless (_deployments.ContainsKey(s.Name))
              CompileSelect(s);
            sequence.Add(SequenceItem.Opaque(MakeDeploymentReference(s.Name, values)))

          | d => assert(false, $"Unknown deployment type $(d.GetType())")
        }
      }

      def sequence = List();
      foreach (d in deployments)
        walk(d, rootValues, sequence, []);

      def result = List();
      mutable compiler : DeploymentCodeCompiler;

      def finalizeCompiler()
      {
        def (deployment, values) = compiler.Compile(_deploymentScriptHeader, _deploymentToolPath);
        def saveDeployment(index)
        {
          def compiledKey = (compiler.Name, index);
          mutable existingDeployment;
          if (_compiledDeployments.TryGetValue(compiledKey, out existingDeployment))
            if (DictionaryEquals(existingDeployment[1].ScriptArgs, deployment.ScriptArgs)
              && DictionaryEquals(existingDeployment[1].DefaultValues, deployment.DefaultValues))
              existingDeployment[0]
            else
              saveDeployment(index + 1)
          else
          {
            def caller  = compiler.TryGetNearestCaller();
            def newName = (caller?.Name ?? "Tdl") + Separators.DeploymentNumberSeparator + _compiledDeployments.Count.ToString();
            _compiledDeployments.Add(compiledKey, (newName, deployment));
            _deployments.Add(newName, deployment);
            newName
          }
        }
        def name = saveDeployment(0);
        result.Add(MakeDeploymentReference(name, values));
        compiler = null;
      }

      foreach (item in sequence)
      {
        | SequenceItem.Opaque(r) =>
          when (compiler != null)
            finalizeCompiler();
          result.Add(r);

        | SequenceItem.Transparent(symbol, values, callStack) =>
          if (compiler : object == null)
            compiler = DeploymentCodeCompiler(symbol, values, callStack);
          else unless (compiler.TryAdd(symbol, values, callStack))
          {
            finalizeCompiler();
            compiler = DeploymentCodeCompiler(symbol, values, callStack);
          }
      }

      when (compiler != null)
        finalizeCompiler();

      when (result.Count == 0)
        result.Add(GetEmptyDeployment());

      result.ToArray()
    }

    private CompileReboot(symbol : DeploymentRebootSymbol) : void
    {
      _deployments.Add(symbol.Name,
        QuickType.Deployment() <-
        {
          Type          = QuickType.TypeEnum.Reboot;
          RebootTimeout = if (symbol.Timeout.HasValue) symbol.Timeout.ValueOrDefault else "00:30:00";
        });
    }

    private CompileScript(script : Deployment.ScriptSymbol) : void
    {
      def refDefs    = HashSet(script.Defs.Where(d => d.Expr is Expr.Reference).Select(d => (d.Expr :> Expr.Reference).Symbol.Name));
      def parameters = script.Parameters.Where(p => !(p.Type is Tdl.ProductTypeSymbol)).Select(p => (p.Name, "$(" + p.Name + ")")).ToArray();
      def defaultes  = MakeDefaultValues(script.Parameters);
      def defs       = script.Defs.Select(d => (d.Name, d.Expr.ToObject()));
      def scriptArgs = parameters.Where((p, _) => !refDefs.Contains(p)).Concat(defs).ToDictionary();

      def deploymentModel = QuickType.Deployment() <- 
      {
        Type           = QuickType.TypeEnum.Script;
        ReturnValue    = if (script.Expected.HasValue)    script.Expected.Value  else null;
        RebootExitCode = if (script.ForReboot.HasValue)   script.ForReboot.Value else null;
        Timeout        = if (script.Timeout.HasValue)     script.Timeout.Value   else null;
        ScriptArgs     = scriptArgs;
        DefaultValues  = defaultes;
      };

      match (script.ScriptReference)
      {
        | FilePath   as x =>
          deploymentModel.ScriptPath          = x.Path.ValueOrDefault;

        | SourceCode as x =>
          deploymentModel.ScriptData          = Encoding.UTF8.GetBytes(x.Text.ValueOrDefault ?? "");
          deploymentModel.ScriptDataExtension = x.Extension.ValueOrDefault;

        | EmbedFile  as x =>
          def path = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(
              script.FirstParsedDeclarationOrDefault.Location.Source.File.FullName), x.Path.Value));
          deploymentModel.ScriptData          = File.ReadAllBytes(path);
          deploymentModel.ScriptDataExtension = Path.GetExtension(path);

        | _ => ()
      }

      _deployments.Add(script.Name, deploymentModel)
    }

    private CompileSelect(sel : Deployment.SelectSymbol) : void
    {
      def separator = Separators.DeploymentSelectSeparator;
      def deployments = sel.Deployments;
      def cases       = sel.Cases;
      assert2(deployments.Length == cases.Length);
      def condition   = string.Join(separator, sel.Parameters.Select(p => "$(" + p.Name + ")"));
      def values      = Dictionary();
      for (mutable i; i < deployments.Length; ++i)
      {
        def selector = string.Join(separator, cases[i].Select(v => v ?? JsonGenerator.ParameterDefaultValue));
        def sequence = CompileSequence(deployments[i], Dictionary(StringComparer.OrdinalIgnoreCase));
        def handler  =
          if (sequence.Length == 1)
            sequence[0]
          else
          {
            def name = sel.Name + separator + selector;
            _deployments.Add(name, QuickType.Deployment() <-
            {
              Type        = QuickType.TypeEnum.Sequence;
              Deployments = sequence;
            });
            MakeDeploymentReference(name, null)
          };
        values.Add(selector, handler)
      }

      _deployments.Add(sel.Name, 
        QuickType.Deployment() <- 
        { 
          Type      = QuickType.TypeEnum.Select;
          Condition = condition;
          Values    = values;
        })
    }

    private CompileCurring(currying : Deployment.CurryingSymbol) : void
    {
      def defaults = MakeDefaultValues(currying.Parameters);
      def values   = Dictionary(StringComparer.OrdinalIgnoreCase);
      foreach (p in currying.ParameterValues)
        values.Add(p.Symbol.Name, p.Expr.ToObject());
      _deployments.Add(currying.Name,
        QuickType.Deployment() <-
        {
            Type          = QuickType.TypeEnum.Sequence;
            Deployments   = CompileSequence(array[currying.BaseDeployment], values);
            DefaultValues = if (defaults.Count == 0) null else defaults;
        })
    }

    private static MakeDefaultValues(parameters : ImmutableArray[FormalParameterSymbol]) : Dictionary[string, object]
    {
      parameters.Select(p => (p.Name, GetDefaultValue(p))).Where(((_, d)) => d != null).ToDictionary()
    }

    private static MakeDeploymentReference(name : string, values : IDictionary[string, object]) : QuickType.TestGroupDeployment
    {
      QuickType.TestGroupDeployment() <-
      {
        DeploymentName = name;
        Parameters = if (values != null && values.Count > 0) values else null
      }
    }

    private static DictionaryEquals(a : IDictionary[string, object], b : IDictionary[string, object]) : bool
    {
      when (a.Count != b.Count)
        return false;

      mutable otherValue;
      foreach (pair in a)
        when (!b.TryGetValue(pair.Key, out otherValue) || !Equals(pair.Value, otherValue))
          return false;

      true
    }
  }
}
