using DotNet;

using Nitra;
using Nitra.BackEnd.Cci;
using Nitra.Declarations;
using Nitra.Internal;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

using System.Threading;
using ND = Nitra.Declarations;

[assembly: ProjectSupport("TdlLang", typeof(Tdl.ProjectSupport))]

namespace Tdl
{
  public partial class ProjectSupport : IProjectSupport, IDisposable
  {
    static NoLocation : Location           = Location(SourceSnapshot.Default.File, NSpan(0));
    static NoFile     : ProjectSystem.File = SourceSnapshot.Default.File;
    static NoSpan     : NSpan              = NSpan(0);

    public TestMode : bool { get; }
    mutable _backEnd : CciBackEnd;
    
    public this()    
    {
      //assert2(false);
      def makeDefaultParameters(ast : ExprBase) : ValueOption[DefaultValue]
      {
        | x   is DotNet.Expr.SimpleName when !x.IsRefEvaluated || !x.Ref.IsSymbolEvaluated => VNone()
        | x   is DotNet.Expr.SimpleName when x.IsRefEvaluated && x.Ref.IsSymbolEvaluated => VSome(DefaultValue.Reference(x.Ref.Symbol.Name))
        | _ => DotNet.Coverters.MakeDefaultParametersOpt(ast)
      }
      DotNet.AstUtils.MakeDefault = makeDefaultParameters;
      DotNet.AstUtils2.ExtensionScopeFactory = CreateExtensionScopeFactory;
    }

    public CreateExtensionScopeFactory(globalScope : Scope) : ScopeFactory
    {
      def self(scope : Scope)
      {
        def globalScope = globalScope;
        assert(true);
        _ = globalScope;
        scope
      }

      self
    }

    
    public this(testMode : bool)
    {
      this();
      TestMode = testMode;
    }

    public Reset(project : Project) : void
    {
      when (_backEnd != null)
      {
        _backEnd.Dispose();
        _backEnd = null;
      }
      project.Data = null;
    }
    
    public RefreshReferences(cancellationToken : CancellationToken, project : Project) : object
    {
      TdlTypeUnifier.InitInstance();

      def bindNs(scope : Scope, name : string) : Ref[NamespaceSymbol]
      {
        //assert2(false);
        def res = Reference(Location.Default, name).Bind.[NamespaceSymbol](scope);
        assert2(!res.IsUnresolved);
        assert2(!res.IsAmbiguous);
        assert2(res.Symbols.Length == 1);
        res
      }
      def bindType(scope : Scope, name : string) : Ref[TopGenericTypeSymbol]
      {
        //assert2(false);
        def res = Reference(Location.Default, name).Bind.[TopGenericTypeSymbol](scope);
        assert2(!res.IsUnresolved);
        assert2(!res.IsAmbiguous);
        assert2(res.Symbols.Length == 1);
        res
      }
      def defineAlias(context : DependentPropertyEvalContext, systemNs : NamespaceSymbol, declaredIn : NamespaceSymbol, name : string, aliasName : string) : void
      {
        def symbolRef  = bindType(systemNs.Scope, name);
        unless (symbolRef.IsSymbolEvaluated)
          return;

        def symbol     = symbolRef.Symbol;
        def decl       = symbol.FirstDeclarationOrDefault :> IExternalTopTypeDeclaration;
        def aliasDecl  = ExternalTopTypeDeclaration.[TypeAliasSymbol](ND.Name(Location.Default, aliasName), decl.Type);
        def alias      = aliasDecl.DefineSymbol(declaredIn.MemberTable);
        alias.Replacement = symbolRef;
        alias.TypeParametersCount = 0;
        alias.TypeParameters      = ImmutableArray.Empty;
        alias.DeclaredIn          = declaredIn;
        alias.EvalProperties(context);
      }

      when (_backEnd != null)
        _backEnd.Dispose();
      def backEnd = CciBackEnd();
      _backEnd = backEnd;
      backEnd.CancellationToken = cancellationToken;
      def deploymentType        = TdlType.DeploymentSymbol();
      def platformType          = TdlType.PlatformSymbol();
      def productType           = TdlType.ProductSymbol();
      def entityType            = TdlType.EntitySymbol();
      def methodType            = FunctionTypeSymbol();
      def scenarioType          = TdlType.ScenarioSymbol();
      def context               = TdlDependentPropertyEvalContext(project, deploymentType, platformType, productType, entityType, methodType, scenarioType);
      def rootNamespace = backEnd.LoadExternalSymbols(project.Libs, project.ProjectDir, project.CompilerMessages, context);
      def systemNsRef   = bindNs(rootNamespace.Scope, "System");
      when (systemNsRef.IsSymbolEvaluated)
      {
        def systemNs = systemNsRef.Symbol;

        defineAlias(context, systemNs, rootNamespace, "Object",  "object");
        defineAlias(context, systemNs, rootNamespace, "Void",    "void");
        defineAlias(context, systemNs, rootNamespace, "String",  "string");
        defineAlias(context, systemNs, rootNamespace, "Boolean", "bool");
        defineAlias(context, systemNs, rootNamespace, "Byte",    "byte");
        defineAlias(context, systemNs, rootNamespace, "SByte",   "sbyte");
        defineAlias(context, systemNs, rootNamespace, "Int16",   "short");
        defineAlias(context, systemNs, rootNamespace, "UInt16",  "ushort");
        defineAlias(context, systemNs, rootNamespace, "Int32",   "int");
        defineAlias(context, systemNs, rootNamespace, "UInt32",  "uint");
        defineAlias(context, systemNs, rootNamespace, "Int64",   "long");
        defineAlias(context, systemNs, rootNamespace, "UInt64",  "ulong");
        defineAlias(context, systemNs, rootNamespace, "Single",  "float");
        defineAlias(context, systemNs, rootNamespace, "Double",  "double");
        defineAlias(context, systemNs, rootNamespace, "Decimal", "decimal");
        defineAlias(context, systemNs, rootNamespace, "Char",    "char");

        methodType.Parameters = ImmutableArray.Empty;
        def symbolRef  = bindType(systemNsRef.Scope, "Void");
        when (symbolRef.IsSymbolEvaluated)
          methodType.Return = symbolRef.Symbol;
      }

      def initTypeSymbol(type : TypeSymbol) : void
      {
        type.EvalProperties(context);
      }
      initTypeSymbol(deploymentType);
      initTypeSymbol(platformType);
      initTypeSymbol(methodType);
      initTypeSymbol(productType);
      initTypeSymbol(entityType);
      initTypeSymbol(scenarioType);


      def baseProductType            = MakeBaseProductTypeSymbol(context, rootNamespace);
      def externalSymbol             = MakeExternalSymbol(context, rootNamespace);
      def scenarioParameterScope     = TableScope("ScenarioParameterScope");
      def requiredScenarioParameters = MakeScenarioParametersScope(backEnd, context, scenarioParameterScope);
      def entityFieldsScope          = MakeEntityFieldsScope(backEnd, context, TableScope("EntityFieldsScope"));
      def data                       = TdlProjectData(backEnd, context, rootNamespace, scenarioParameterScope, entityFieldsScope, requiredScenarioParameters, externalSymbol, TestMode, baseProductType);
      context.TdlProjectData         = data;

      def emptyDeployment = ExternalDeclaration.[Tdl.Deployment.EmptySymbol](Location.Default, "Empty", ignoreCase = true).DefineSymbol(rootNamespace.MemberTable);
      // TODO: эти свойства должны вычисляться в EvalProperties
      emptyDeployment.Type                     = deploymentType;
      emptyDeployment.Scope                    = EmptyScope.Instance;
      emptyDeployment.AllDeployments           = ImmutableArray.Create();
      emptyDeployment.AggregateParametersScope = EmptyScope.Instance;
      emptyDeployment.EvalProperties(context);

      data
    }

    public TryIncrementalRefreshProject(cancellationToken : CancellationToken, before : IAst, after : IAst, data : object) : bool
    {
      IgnoreParams();
      def symbols = HashSet();
      def symbols = symbols;
      before.Accept(n => _ = symbols.Add(n), null);
      _ = symbols;
      false // we not support incremental refresh yet.
    }

    public RefreshProject(cancellationToken : CancellationToken, files : ImmutableArray[FileEvalPropertiesData], data : object) : void
    {
      def projectData           = data :> TdlProjectData;
      def backEnd               = projectData.BackEnd;
      def context               = projectData.Context :> TdlDependentPropertyEvalContext;
      def rootNamespace         = projectData.RootNamespace;
      context.CancellationToken = cancellationToken;
      backEnd.CancellationToken = cancellationToken;
      context.InitialDeployment = null;
      context.FinalDeployment   = null;

      def removeParsedSymbols(tableScope : TableScope)
      {
        when (cancellationToken.IsCancellationRequested)
          return;
        
        tableScope.Undefine(x => { cancellationToken.ThrowIfCancellationRequested(); x.IsParsed });
        foreach (symbols in tableScope.Symbols)
        foreach (symbol is NamespaceSymbol in symbols)
          removeParsedSymbols(symbol.MemberTable);
      }
      removeParsedSymbols(rootNamespace.MemberTable);
      removeParsedSymbols(projectData.ExternalSymbolTable);

      when (cancellationToken.IsCancellationRequested)
        return;

      def evalHost = TdlProjectEvalPropertiesHost(files, projectData);
      evalHost.EvalProperties(context, "SymbolHierarchy", 0);
      evalHost.EvalProperties(context, "Scopes", 1);
      evalHost.EvalProperties(context, "Stage 2", 2);
      evalHost.EvalProperties(context, "Stage 3", 3);
      evalHost.EvalProperties(context, "Stage 4", 4);
      evalHost.Finish();
      CheckScenarios(context, rootNamespace.MemberTable);
    }

    public CheckScenarios(context : DependentPropertyEvalContext, root : TableScope) : void
    {
      def scenarios = root.AllSymbols.OfType.[ScenarioSymbol]().ToArray();
      CheckParallelScenarios(context, scenarios);
      
      def uniqueIds = scenarios.OfType.[Scenario.DefSymbol]()
        .Where(sd => sd.IsDefsEvaluated && sd.Defs.Any(d => d.Symbol.Name == "UniqueId"))
        .Select(sd => (sd, sd.Defs.Single(d => d.Symbol.Name == "UniqueId")));
      def groupedByDef = uniqueIds.GroupBy((_, d) => d.Expr.ToString());
      
      foreach (group when group.Count() > 1 in groupedByDef)
      {
        def names = string.Join(", ", group.Select((sd, _) => sd.Name));
        foreach ((scenario, d) in group)
        {
          def value = d.Expr;
          def decl  = scenario.FirstDeclarationOrDefault :> Scenario.Def;
          foreach (definition when definition.IsSymbolRefEvaluated && definition.SymbolRef.IsSymbolEvaluated in decl.Definitions)
          {
            when (definition.SymbolRef.Symbol.Id == d.Symbol.Id)
            {
              definition.Reference.Error(context, $"Scenarios $names have the same UniqueId value ($value).", 0);
            }
          }
        }
      }
    }

    public CheckParallelScenarios(context : DependentPropertyEvalContext, scenarios : array[ScenarioSymbol]) : void
    {
      def scenarioSets = scenarios.OfType.[Scenario.SetSymbol]().Where(s => s.IsIsMultiMachineEvaluated && s.IsMultiMachine);
      def groups       = scenarioSets.Where(s => s.IsScenariosEvaluated)
                                     .SelectMany(mms => mms.Scenarios.Select(s => (mms, s)))
                                     .GroupBy((_, s) => s);

      // Данная проверка нужна так как в текущем API Hive-а нельзя включать сценарий в несколько многомашинных сценариев.
      foreach (group when group.Count() > 1 in groups)
      {
        def scenario = group.Key;
        def sets     = group.Select(((set, _), _) => set).ToArray();
        def names    = string.Join(", ", sets.Select(s => s.Name));
        foreach (set in sets)
        {
          def decl1 = set.FirstDeclarationOrDefault :> Scenario.Set;
          def r1    = decl1.Scenarios.FirstOrDefault(d => d.IsRefEvaluated && d.Ref.IsSymbolEvaluated && d.Ref.Symbol.Id == scenario.Id);
          when (r1 == null)
            continue;
          def msgs  = context.GetFileData(r1.Location.Source.File.Id).GetCompilerMessage();
          using (rootMsg = msgs.RootError(r1, $"Scenario $(scenario.Name) is included in several parallel scenarios: $names.", 0))
          {
            foreach (s when s.Id != set.Id in sets)
            {
              def decl2 = s.FirstDeclarationOrDefault :> Scenario.Set;
              def r2    = decl2.Scenarios.FirstOrDefault(d => d.IsRefEvaluated  && d.Ref.IsSymbolEvaluated && d.Ref.Symbol.Id == scenario.Id);
              when (r2 == null)
                continue;
              rootMsg.Warning(r2.Location, "Other entry", 0);
            }
          }
        }
      }
      
      foreach (set in scenarioSets)
      {
        def scenarios        = TdlUtils.GetSetScenarios(set);
        def barriersCountMap = Dictionary();
        foreach (scenario in scenarios)
        {
          scenario.ParallelSetOpt = set;

          // Claculate count of barrier usages.
          def inc(barrier : BarrierSymbol) : void
          {
            mutable value;
            _ = barriersCountMap.TryGetValue(barrier, out value);
            barriersCountMap[barrier] = value + 1;
          }
          when (scenario.IsActionsEvaluated)
            foreach (b is ScenarioAction.Barrier in scenario.Actions)
              inc(b.barrier);
        }
        set.BarriersCount = barriersCountMap.Map(x => (x.Key, x.Value));
      }
    }
    
    public GetSymbolById(data : object, symbolId : int) : ValueOption[DeclarationSymbol]
    {
      def projectData = DecomposeData(data);
      // TODO: cache symbols an use it cache to find symbol by id
      def findSymbol(symbols : Seq[DeclarationSymbol]) : ValueOption[DeclarationSymbol]
      {
        foreach (symbol in symbols)
        {
          when (symbol.Id == symbolId)
            return ValueOption.Some(symbol);

          match (symbol)
          {
            | t is GenericContainerTypeSymbol =>
              def result = findSymbol(t.NestedTypes);
              when (result.IsSome)
                return result;

            | NamespaceSymbol as ns =>
              foreach (symbols in ns.MemberTable.Symbols)
              {
                def result = findSymbol(symbols);
                when (result.IsSome)
                  return result;
              }

            | _ => ()
          }
        }

        ValueOption.None()
      }

      def result = findSymbol(projectData.RootNamespace.MemberTable.GetAllSymbols());
      when (result.IsSome)
        return result;

      ValueOption.None()
    }

    public DeconstructType(symbol : DeclarationSymbol, type : out TypeSymbol, typeArgs : out ImmutableArray[TypeSymbol]) : bool
    {
      match (symbol)
      {
        | s is TopConstructedTypeSymbol    => type = s.TypeInfo; typeArgs = s.Args; true
        | s is NestedConstructedTypeSymbol => type = s.TypeInfo; typeArgs = s.Args; true
        | _ => type = null; typeArgs = ImmutableArray.Empty; false
      }
    }

    public VisitGlobalSymbols(data : object, callback : Predicate[DeclarationSymbol]) : void
    {
      def projectData = DecomposeData(data);
      _ = projectData.RootNamespace.VisitChildrenAndSelf(SymbolUtils.GetNestedSymbol, callback);
    }

    public Postprocessing(cancellationToken : System.Threading.CancellationToken, project : Nitra.ProjectSystem.Project, asts : System.Collections.Immutable.ImmutableArray[(Nitra.Declarations.IAst * bool)], data : object) : void
    {
      IgnoreParams();
    }

    public DecomposeData(data : object) : TdlProjectData
    {
      data :> TdlProjectData
    }

    public MakeBaseProductTypeSymbol(context : TdlDependentPropertyEvalContext, rootNamespace : NamespaceSymbol) : ProductTypeSymbol
    {
      def symbol = ExternalDeclaration.[ProductTypeSymbol](Name(NoLocation, "BaseProductType")).DefineSymbol(rootNamespace.MemberTable);
      symbol.BaseTypeSet = BaseTypeReferenceSet(null);
      symbol.EvalProperties(context);
      symbol
    }
    
    public MakeExternalSymbol(context : TdlDependentPropertyEvalContext, rootNamespace : NamespaceSymbol) : ExternalSymbol
    {
      def parameterName = Name(NoLocation, "external");
      def symbol = ExternalDeclaration.[ExternalSymbol](parameterName).DefineSymbol(rootNamespace.MemberTable);
      symbol.EvalProperties(context);
      symbol
    }
    
    public MakeScenarioParametersScope(backEnd : IDotNetBackEnd, context : TdlDependentPropertyEvalContext, scenarioParameterScope : TableScope) : ImmutableArray[FormalParameterSymbol]
    {
      def requiredScenarioParametersBuilder = ImmutableArray.CreateBuilder();
      
      mutable index;
      
      def defineParameter(context : TdlDependentPropertyEvalContext, name : string, type : TypeSymbol, required : bool) : void
      {
        def parameterName  = Name(NoLocation, name); // TODO: type.Name.UniqueKey
        def parameter      = ExternalDeclaration.[FormalParameterSymbol](parameterName).DefineSymbol(scenarioParameterScope);
        when (required)
          _                = requiredScenarioParametersBuilder.Add(parameter);
        parameter.Type     = type;
        parameter.Modifier = ParameterModifier.None;
        parameter.Index    = index;
        index++;
        parameter.EvalProperties(context);
      }

      def platformType = backEnd.PlatformType;
      
      defineParameter(context, "Area",                            platformType.String,  required=false);
      defineParameter(context, "ArtifactsCollectionTimeout",      platformType.String,  required=false);
      defineParameter(context, "EnforceBinariesFolderUniqueness", platformType.Boolean, required=false);
      defineParameter(context, "LocalTestBinariesFolder",         platformType.String,  required=false);
      defineParameter(context, "MaxRebootsCount",                 platformType.Int32,   required=false);
      defineParameter(context, "NeedUnsignedAgent",               platformType.Boolean, required=false);
      defineParameter(context, "ProductGroupName",                platformType.String,  required=false);
      defineParameter(context, "RequireInternet",                 platformType.Boolean, required=false);
      defineParameter(context, "ExternalAutotestId",              platformType.Int32,   required=false);
      defineParameter(context, "RerunCountOnTestFailure",         platformType.Int32,   required=false);
      defineParameter(context, "RerunCountOnTestSuccess",         platformType.Int32,   required=false);
      defineParameter(context, "Responsible",                     platformType.String,  required=false);
      defineParameter(context, "RevertAgentAfter",                platformType.Boolean, required=false);
      defineParameter(context, "RevertAgentBefore",               platformType.Boolean, required=false);
      defineParameter(context, "TfsId",                           platformType.Int32,   required=false);
      defineParameter(context, "Timeout",                         platformType.String,  required=true);
      defineParameter(context, "UniqueId",                        platformType.String,  required=true);

      requiredScenarioParametersBuilder.ToImmutable();
    }
    
    public MakeEntityFieldsScope(backEnd : IDotNetBackEnd, context : TdlDependentPropertyEvalContext, entityFieldsScope : TableScope) : TableScope
    {
      mutable index;
      
      def defineField(context : TdlDependentPropertyEvalContext, name : string, type : TypeSymbol, required : bool) : void
      {
        _ = required;
        def parameterName  = Name(NoLocation, name); // TODO: type.Name.UniqueKey
        def parameter      = ExternalDeclaration.[FormalParameterSymbol](parameterName).DefineSymbol(entityFieldsScope);
        parameter.Type     = type;
        parameter.Modifier = ParameterModifier.None;
        parameter.Index    = index;
        index++;
        parameter.EvalProperties(context);
      }

      def platformType = backEnd.PlatformType;
      
      defineField(context, "Name",       platformType.String, required=true);
      defineField(context, "BranchName", platformType.String, required=true);
      defineField(context, "Version",    platformType.String, required=true);
      defineField(context, "Type",       platformType.String, required=true);
      
      //requiredScenarioParametersBuilder.ToImmutable();
      entityFieldsScope
    }

    public Dispose() : void
    {
      when (_backEnd != null)
        _backEnd.Dispose();
    }
  }
}
