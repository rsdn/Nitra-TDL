using DotNet;
using DotNet.AstUtils;

using Nitra;
using Nitra.Internal;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Runtime.GraphUtils;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;

namespace Tdl
{
  module TdlUtils
  {
    public NoLocation         : Location           = Location(SourceSnapshot.Default.File, NSpan(0));
    public NoFile             : ProjectSystem.File = SourceSnapshot.Default.File;
    public NoSpan             : NSpan              = NSpan(0);

    RequiredProductTypeFields : list[string] = ["Name", "Version"];
    ObsoleteProductTypeFields : Dictionary[string, string] = [("ReleaseName", "BranchName")].ToDictionary();

    public BaseStableGuid : Guid = Guid.Parse("{AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA}");

    public ToDictionary[TKey, TValue](this seq : Seq[TKey * TValue]) : Dictionary[TKey, TValue]
    {
      def dictionary = Dictionary();
      foreach ((k, v) in seq)
        dictionary.Add(k, v);
      dictionary
    }

    public ToTdlContext(this context : DependentPropertyEvalContext) : TdlDependentPropertyEvalContext
    {
      context :> TdlDependentPropertyEvalContext;
    }

    public GetEntityFieldsScope(this context : DependentPropertyEvalContext) : TableScope
    {
      ToTdlContext(context).TdlProjectData.EntityFieldsScope
    }

    public GetBarrierScope(this context : DependentPropertyEvalContext) : Scope
    {
      context.BindType("TdlInternals.Predefined", 0).Scope
    }

    public GetExternalSymbolTable(this context : DependentPropertyEvalContext) : TableScope
    {
      ToTdlContext(context).TdlProjectData.ExternalSymbolTable
    }

    public GetIsPredefinedSuiteField(this context : DependentPropertyEvalContext) : string -> bool
    {
      value => ToTdlContext(context).PredefinedSuiteFields.Contains(value)
    }

    public GetIsNotPredefinedSuiteField(this context : DependentPropertyEvalContext) : string -> bool
    {
      value => !ToTdlContext(context).PredefinedSuiteFields.Contains(value)
    }

    public GetDeploymentTypeSymbol(this context : DependentPropertyEvalContext) : DeploymentTypeSymbol
    {
      ToTdlContext(context).TdlProjectData.DeploymentType
    }

    public GetDeploymentImportScope(this context : DependentPropertyEvalContext) : Scope
    {
      GetDeploymentTypeSymbol(context).DeploymentImportFields
    }

    public GetProductTypeSymbol(this context : DependentPropertyEvalContext) : ProductTypeSymbol
    {
      ToTdlContext(context).TdlProjectData.BaseProductType
    }

    public GetPlatformTypeSymbol(this context : DependentPropertyEvalContext) : PlatformTypeSymbol
    {
      ToTdlContext(context).TdlProjectData.PlatformType
    }

    public GetScenarioParameterScope(this context : DependentPropertyEvalContext) : Scope
    {
      ToTdlContext(context).TdlProjectData.ScenarioParameterScope
    }

    public GetVmCapabilityScope(this context : DependentPropertyEvalContext) : Scope
    {
      ToTdlContext(context).TdlProjectData.VmCapabilityScope
    }

    public GetRequiredScenarioParameters(this context : DependentPropertyEvalContext) : ImmutableArray[FormalParameterSymbol]
    {
      ToTdlContext(context).TdlProjectData.RequiredScenarioParameters
    }

    public GetMethodScopeFactory(this context : DependentPropertyEvalContext) : ScopeFactory
    {
      ToTdlContext(context).TdlProjectData.MethodScopeFactory
    }

    public GetCommandScopeFactory(this context : DependentPropertyEvalContext) : ScopeFactory
    {
      ToTdlContext(context).TdlProjectData.CommandScopeFactory
    }

    public GetCommandParametersScope(this context : DependentPropertyEvalContext, scope : Scope) : Scope
    {
      ToTdlContext(context).TdlProjectData.CommandParametersScopeFactory(scope)
    }

    public GetCommandParameterValuesScope(this _context : DependentPropertyEvalContext, scope : Scope, stepNumber : int) : Scope
    {
      scope.FilterWith(
        fun (_)
        {
          | CommmandCallOutputArgumentSymbol as s => s.IsStepNumberEvaluated && s.StepNumber < stepNumber
          | _ => true
        })
    }

    public PlatformMakeHint(symbolCache : ISymbolCache, symbol : Platform.SetSymbol) : string
    {
      def builder = StringBuilder();
      try
      {
        symbolCache?.CacheSymbol(symbol);
        _ = builder.Append("<keyword>").HintMlEscape(symbol.Kind).Append("</keyword> ")
          .SymbolToHintMlWithSubHint(symbol)
          .Append(" = ");

        if (symbol.IsPlatformsEvaluated)
          _ = builder.Join(symbol.Platforms, HintML.SymbolToHintMlWithSubHint(_, _))
        else
          _ = builder.Append(<# <b><font color="Red">The Platforms not evaluated</font></b>.#>);

        _ = builder.MakeLocations(symbol);
      }
      catch { e => _ = builder.HintMlException(e); }
      builder.ToString()
    }

    public DeploymentMakeHint(symbolCache : ISymbolCache, symbol : DeploymentSymbol) : string
    {
      def builder = StringBuilder();
      try
      {
        symbolCache?.CacheSymbol(symbol);
        _ = builder.Append("<keyword>").HintMlEscape(symbol.Kind).Append("</keyword> ")
          .SymbolToHintMlWithSubHint(symbol)
          .AppendLine();

        def project = symbolCache :> Project;

        def rootNs = (project.Data :> TdlProjectData).RootNamespace;

        def scenarios = rootNs.MemberTable
          .GetAllSymbols()
          .OfType.[Scenario.DefSymbol]()
          .Where(s => s.Deployment.Id == symbol.Id || s.Deployment.AllDeployments.Contains(symbol))
          .ToList();

        if (scenarios.Count == 0)
          _ = builder.Append(<#Deployment is not used in any scenario.#>);
        else
        {
          _ = builder.Append("Deployment is used in the following scenarios:\n   ");
          _ = builder.Join(scenarios.Take(10), HintML.SymbolToHintMlWithSubHint(_, _));
          when (scenarios.Count > 10)
            _ = builder.Append($<#Deployment is used in $(scenarios.Count) scenarios.#>);
        }

        _ = builder.MakeLocations(symbol);
      }
      catch { e => _ = builder.HintMlException(e); }
      builder.ToString()
    }

    public MakeDeployments(deploymentRefs : ImmutableArray[Ref[DeploymentSymbol]]) : ImmutableArray[DeploymentSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (r in deploymentRefs)
      {
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeAllProducts(it : ProductSymbol, products : ImmutableArray[ProductSymbol]) : ImmutableArray[Product.DefSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      def visited = HashSet();
      _ = visited.Add(it.Id);

      def collect(products : ImmutableArray[ProductSymbol]) : void
      {
        foreach (product in products)
        {
          unless (visited.Add(product.Id))
            continue;

          match (product)
          {
            | p   is Product.DefSymbol => builder.Add(p);
            | set is Product.SetSymbol => collect(set.Products);
            | _ => ()
          }
        }
      }

      collect(products);

      builder.ToImmutable()
    }

    public MakeProducts(deploymentRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ProductSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (deploymentRef in deploymentRefs)
      {
        def r = deploymentRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeScenarios(scenariosRefs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[ScenarioSymbol]
    {
      def builder = ImmutableArray.CreateBuilder();
      foreach (scenariosRef in scenariosRefs)
      {
        def r = scenariosRef.Resolve();
        when (r.IsSymbolEvaluated)
          builder.Add(r.Symbol);
      }
      builder.ToImmutable()
    }

    public MakeAggregateParametersScope(deployments : Seq[DeploymentSymbol], initialScope : Scope = null) : ValueOption[Scope]
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      UnionScopeBuilder.Add(initialScope, ref builder);
      if (CollectDeployments(visited, ref builder, deployments))
        VSome(builder.ToScope())
      else
        VNone()
    }

    private CollectDeployments(visited : HashSet[int], builder : ref UnionScopeBuilder, deployments : Seq[DeploymentSymbol]) : bool
    {
      foreach (deployment in deployments)
      {
        unless (visited.Add(deployment.Id))
          continue;

        unless (deployment.IsAggregateParametersScopeEvaluated)
          return false;
        UnionScopeBuilder.Add(deployment.AggregateParametersScope, ref builder);
      }
      true
    }

    public MakeAggregateParametersScope(scenarios : ImmutableArray[ScenarioSymbol], context : DependentPropertyEvalContext) : ValueOption[Scope]
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();

      if (CollectScenarios(visited, ref builder, scenarios))
        VSome(builder.ToScope())
      else
        VNone()
    }

    private CollectScenarios(visited : HashSet[int], builder : ref UnionScopeBuilder, scenarios : ImmutableArray[ScenarioSymbol]) : bool
    {
      foreach (scenario when visited.Add(scenario.Id) in scenarios)
      {
        unless (scenario.IsAggregateParametersScopeEvaluated)
          return false;
        UnionScopeBuilder.Add(scenario.AggregateParametersScope, ref builder);
      }
      true
    }

    public MakeExpected(valueOpt : DeploymentOption.Success.IAstOption) : ParsedValue[int]
    {
      if (valueOpt.HasValue) valueOpt.Value.Value else ParsedValue(valueOpt.Span.StartPos)
    }

    public MakeForReboot(valueOpt : DeploymentOption.ForReboot.IAstOption) : ParsedValue[int]
    {
      if (valueOpt.HasValue) valueOpt.Value.Value else ParsedValue(valueOpt.Span.StartPos)
    }

    public ConvertStringLiteral(this valueOpt : DeploymentOption.Timeout.IAstOption) : ParsedValue[string]
    {
      if (valueOpt.HasValue) TdlUtils.ConvertStringLiteral(valueOpt.Value.Value) else ParsedValue(valueOpt.Span.StartPos)
    }

    //public ConvertStringLiteral(this valueOpt : CSharp.StringLiteral.IAstOption) : ParsedValue[string]
    //{
    //  if (valueOpt.HasValue) TdlUtils.ConvertStringLiteral(valueOpt.Value) else ParsedValue(valueOpt.Span.StartPos)
    //}

    public ConvertStringLiteralOrNull(str : CSharp.StringLiteral) : string
    {
      def rsult = ConvertStringLiteral(str);
      if (rsult.HasValue)
        rsult.Value
      else
        null
    }

    [DebuggerStepThroughAttribute]
    private HexDigit(c : char) : int
    {
      | c when '0' <= c && c <= '9' => c : int - '0' : int
      | c when 'a' <= c && c <= 'f' => c : int - 'a' : int + 10
      | c when 'A' <= c && c <= 'F' => c : int - 'A' : int + 10
      | _ => assert3(false)
    }

    [DebuggerStepThroughAttribute]
    public HexToInt(location : Location, startPos : int, endPos : int) : int
    {
      assert2(startPos < endPos);

      def text = location.Source.OriginalText;
      mutable result = HexDigit(text[startPos]);

      for (mutable i = startPos + 1; i < endPos; i++)
        unchecked result = (result << 4) + HexDigit(text[i]);

      result
    }

    public ConvertStringLiteral(str : CSharp.StringLiteral) : ParsedValue[string]
    {
      def builder = Text.StringBuilder();
      foreach (part in str.Parts)
      {
        | Interpolation           => ()
        | InterpolationFormated   => ()
        | InterpolatedOpenEscape  => _ = builder.Append("{");
        | InterpolatedCloseEscape => _ = builder.Append("}");
        | Error                   => ()
        | SimpleEscape       as x =>
          def text = x.Source.Text;
          _ = builder.Append(DotUtils.EscapeSequence(text[x.Span.StartPos + 1]));

        | UnicodeEscape      as x
        | HexadecimalEscape  as x =>
          def span = x.Span;
          def value = HexToInt(part.Location, span.StartPos + 3, span.EndPos);
          try
            _ = builder.Append(value :> char);
          catch { _ is OverflowException => return ParsedValue(str.Span.StartPos); }

        | RegulaChars             => _ = builder.Append(part.Location.GetText());
        | VerbatimEscape          => _ = builder.Append('"');
        | _                       => ()
      }

      ParsedValue(str.Span, builder.ToString())
    }

    public CreateEmbedFilePath(str : CSharp.StringLiteral, context : DependentPropertyEvalContext) : ParsedValue[string]
    {
      def rawValue = ConvertStringLiteral(str);

      when (!rawValue.HasValue || string.IsNullOrEmpty(rawValue.Value))
      {
        str.Error(context, "Deployment file path required.");
        return rawValue
      }

      try
      {
        def path = ExpandPathRelativeToAst(str, rawValue.Value);

        unless (File.Exists(path))
          str.Error(context, $"Deployment file '$(path)' not found.");

        rawValue
      }
      catch
      {
        | e is Exception =>
          str.Error(context, $"Failed to process deployment file path ($(e.GetType())): $(e.Message)");
          rawValue
      }
    }

    public MakeDefinitions(context : DependentPropertyEvalContext, definitions : Definition.IAstList, _dependence : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[Def]
    {
      def builder = ImmutableArray.CreateBuilder(definitions.Count);
      foreach (definition when definition.IsSymbolRefEvaluated && definition.SymbolRef.IsSymbolEvaluated && definition.Expr.IsResultEvaluated in definitions)
      {
        def sym    = definition.SymbolRef.Symbol;
        def result = definition.Expr.Result;
        when (sym.Name.Equals("UniqueId", StringComparison.InvariantCultureIgnoreCase))
        {
          def strGuid = result.GetValue().ToString();
          mutable guid;
          unless (Guid.TryParse(strGuid, out guid))
            definition.Expr.Error(context, <#Invalid GUID.#>);
        }

        builder.Add(Def(sym, result));
      }
      builder.TryMoveToImmutable()
    }

    public MakeDefinitions(definitions : IAstList[Definition], context : DependentPropertyEvalContext, type : TypeSymbol, _dependence : ImmutableArray[Ref[TypedDeclarationSymbol]], baseSuiteOpt : ValueOption[Suite.DefSymbol], isIgnore : string -> bool = null) : ValueOption[ImmutableArray[Def]]
    {
      when (baseSuiteOpt is VSome(x) when !x.IsDefsEvaluated)
        return VNone();

      def builder         = ImmutableArray.CreateBuilder(definitions.Count);
      def existsDefsNames = HashSet();
      foreach (definition when definition.IsSymbolRefEvaluated && definition.SymbolRef.IsSymbolEvaluated && definition.Expr.IsResultEvaluated in definitions)
      {
        def sym = definition.SymbolRef.Symbol;
        builder.Add(Def(sym, definition.Expr.Result));
        _ = existsDefsNames.Add(GetCaseInsensitiveId(sym));
      }

      foreach(FieldSymbol(IsValueEvaluated=true, Value=VSome(expr)) as field when !existsDefsNames.Contains(GetCaseInsensitiveId(field)) in type.Scope.GetAllSymbols())
        when (isIgnore == null || !isIgnore(field.Name))
          builder.Add(Def(field, expr));

      when (baseSuiteOpt is VSome(x))
        foreach (d when !existsDefsNames.Contains(GetCaseInsensitiveId(d.Symbol)) in x.Defs)
          builder.Add(d);

      VSome(builder.TryMoveToImmutable())
    }

    public MakeUntypedDefinitions(definitions : Definition.IAstList, context : DependentPropertyEvalContext, requiredNames : Seq[string] = null) : ImmutableArray[UntypedDef]
    {
      def declaredNames = HashSet();
      def builder       = ImmutableArray.CreateBuilder(definitions.Count);

      foreach (definition when definition.Expr.IsResultEvaluated in definitions)
      {
        def name = definition.Reference.Text;
        if (!declaredNames.Add(name))
          definition.Reference.Error(context, $"Redefinition of name '$name'.")
        else
          builder.Add(UntypedDef(name, definition.Expr.Result));
      }

      when (requiredNames : object != null)
      {
        foreach (n in requiredNames)
        {
          unless (declaredNames.Contains(n))
          {
            def msgs = context.GetFileData(definitions.Location.Source.File.Id).GetCompilerMessage();
            msgs.Error(definitions.Location.FromStart(), $"Definition of '$n' is required.");
          }
        }
      }

      builder.TryMoveToImmutable()
    }

    public Resolve[TSymbol](refs : ImmutableArray[Ref[DeclarationSymbol]]) : ImmutableArray[Ref[TSymbol]]
      where TSymbol : DeclarationSymbol
    {
      def builder = ImmutableArray.CreateBuilder(refs.Length);
      foreach (r in refs)
        builder.Add(r.Resolve());
      builder.TryMoveToImmutable()
    }

    /// Skip unresolved symbols.
    public ToSymbol[T](symbols : ImmutableArray[Ref[T]]) : ImmutableArray[T]
      where T : DeclarationSymbol
    {
      def builder = ImmutableArray.CreateBuilder(symbols.Length);
      foreach (r when r.IsSymbolEvaluated in symbols)
        builder.Add(r.Symbol);

      builder.TryMoveToImmutable()
    }

    public Flatten[T](a : ImmutableArray[ImmutableArray[T]]) : Seq[T]
    {
      a.SelectMany(x => x)
    }

    public Flatten(symbols : ImmutableArray[SuiteSymbol]) : ImmutableArray[SuiteSymbol]
    {
      def getChildren(symbol)
      {
        | sx is Suite.ListSymbol => sx.Suites
        | _                      => default(ImmutableArray[SuiteSymbol])
      }
      Flatten(symbols, getChildren)
    }

    public Flatten[T](symbols : ImmutableArray[T], getChildren : T -> ImmutableArray[T]) : ImmutableArray[T]
      where T : DeclarationSymbol
    {
      def builder = ImmutableArray.CreateBuilder(symbols.Length);
      def visited = HashSet();

      def loop(symbols : ImmutableArray[T])
      {
        foreach (symbol when visited.Add(symbol) in symbols)
        {
          def children = getChildren(symbol);
          if (children.IsDefault)
            builder.Add(symbol)
          else
            loop(children)
        }
      }
      loop(symbols);

      builder.TryMoveToImmutable()
    }

    public ToSymbol(it : PlatformSymbol, platforms : ImmutableArray[Ref[PlatformSymbol]]) : ImmutableArray[PlatformSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(platforms.Length);
      def visited = HashSet();
      _ = visited.Add(it);
      def loccectAllPlatforms(platforms : ImmutableArray[Ref[PlatformSymbol]])
      {
        foreach (platformRef when platformRef.IsSymbolEvaluated in platforms)
        {
          unless (visited.Add(platformRef.Symbol))
            continue;
          match (platformRef.Symbol)
          {
            | s is Platform.DefSymbol => builder.Add(s);
            | s is Platform.SetSymbol => loccectAllPlatforms(s.PlatformsRefs);
            | _ => assert(false)
          }
        }
      }

      loccectAllPlatforms(platforms);

      builder.TryMoveToImmutable()
    }

    public MakeExcludedParams(baseDeploymentRefs : ImmutableArray[Ref[TypedDeclarationSymbol]]) : ImmutableArray[FormalParameterSymbol]
    {
      def builder = ImmutableArray.CreateBuilder(baseDeploymentRefs.Length);
      foreach (r in baseDeploymentRefs)
      {
        def res = r.Resolve.[FormalParameterSymbol]();
        when (res.IsSymbolEvaluated)
          builder.Add(res.Symbol);
      }
      builder.TryMoveToImmutable()
    }

    public MakeCurryingScope(scope : Scope, excludedParams : ImmutableArray[FormalParameterSymbol]) : Scope
    {
      def predicate(symbol : DeclarationSymbol) : bool
      {
        def id = symbol.Id;
        foreach (excludedParam in excludedParams)
          when (excludedParam.Id == id)
            return false;

        true
      }
      scope.FilterWith(predicate)
    }

    public FilterDeployment(defs : ImmutableArray[Def]) : List[DeploymentSymbol]
    {
      def deployments = List();
      foreach (Def(Expr=Expr.Reference(Symbol=DeploymentSymbol as d)) in defs)
        deployments.Add(d);
      deployments
    }

    //public FilterDeploymentDefs(defs : ImmutableArray[Def]) : List[TypedDeclarationSymbol * DeploymentSymbol]
    //{
    //  def deployments = List();
    //  foreach (Def(Symbol=s, Expr=Expr.Reference(Symbol=DeploymentSymbol as d)) in defs)
    //    deployments.Add(s, d);
    //  deployments
    //}

    public MakeParameterScope(scope : Scope, predefineds : ImmutableArray[Def], baseSuiteOpt : ValueOption[Suite.DefSymbol]) : ValueOption[Scope]
    {
      when (baseSuiteOpt is VSome(x) when !x.IsDefaultDefsEvaluated || !x.IsDefinitionScopeEvaluated || !x.IsDefsEvaluated)
        return VNone();

      def deployments = FilterDeployment(predefineds);

      def scopeOpt = MakeAggregateParametersScope(deployments, scope);

      if (scopeOpt is VSome(scope))
      {
        def scope2 = if (baseSuiteOpt is VSome(x)) x.DefinitionScope.HideWith(scope) else scope;

        def internTable = Dictionary(ParameterComparer());
        def isInternedSymbol(symbol)
        {
          mutable internedSymbol;
          if (internTable.TryGetValue(symbol, out internedSymbol))
            symbol : object == internedSymbol
          else
          {
            internTable.Add(symbol, symbol);
            true
          }
        }
        VSome(scope2.Memoize().FilterWith(isInternedSymbol))
      }
      else
        VNone()
    }

    public TryMoveToImmutable[T](this builder : ImmutableArray[T].Builder) : ImmutableArray[T]
    {
      if (builder.Capacity == builder.Count)
        builder.MoveToImmutable()
      else
        builder.ToImmutable()
    }

    public MakeDeploymentScope(scope : Scope) : Scope
    {
      def filter(symbol : DeclarationSymbol) : bool
      {
        | DeploymentSymbol => true
        | _                => false
      }

      scope.FilterWith(filter)
    }

    public CheckRequired(this ast : IAst, context : DependentPropertyEvalContext, name : string, requiredFields : Seq[DeclarationSymbol], fields : ImmutableArray[Def], _dependency : object = null) : void
    {
      def defSet        = fields.Select(d => d.Symbol);
      def missingFields = requiredFields.Except(defSet).MapToArray(x => x.InitialName);
      def count         = missingFields.Length;
      unless (missingFields.IsEmpty())
        ast.Error(context, $<#The following $(name)$(if (count == 1) "" else "s") are required: ..$missingFields.#>);
    }

    public ValidateParameters(this ast : Suite, context : DependentPropertyEvalContext, suiteDefs : ImmutableArray[Def], suiteStatements : ImmutableArray[SuiteStatement], productScope : Scope, _defaultDefs : ImmutableArray[FormalParameterSymbol]) : void
    {
      try
      {
        def definedParameters = HashSet();
        foreach (s in productScope.GetAllSymbols())
          _ = definedParameters.Add(s.NameId);
        foreach (d in suiteDefs)
          _ = definedParameters.Add(d.Symbol.NameId);

        mutable hasUnconditionalScenario;
        def undefinedParameters = HashSet();
        foreach (statement in suiteStatements)
        {
          | CallScenario(scenaro) =>
            when (scenaro.IsIsUnconditionalEvaluated && scenaro.IsUnconditional)
              hasUnconditionalScenario = true;

            when (scenaro.IsAggregateParametersScopeEvaluated)
            {
              def scenarioScope = scenaro.AggregateParametersScope;
              foreach (parameter is FormalParameterSymbol when parameter.IsTypeEvaluated && parameter.IsDeclaredInEvaluated in scenarioScope.GetAllSymbols())
              {
                when (definedParameters.Contains(parameter.NameId)
                   || parameter.HasDefault()
                   || parameter.DeclaredIn is Deployment.SelectSymbol
                   || parameter.Type is SuiteTypeSymbol)
                  continue; // OK

                when (undefinedParameters.Add(parameter.NameId))
                {
                  def msgs = CompilerMessagesExtensions.GetCompilerMessage(context, ast);
                  using (root = msgs.RootError(ast.Name, $"Value is not specified for parameter '$(parameter)' declared in '$(parameter.DeclaredIn)'."))
                  {
                    def parameterDefinition = parameter.FirstParsedDeclarationOrDefault;
                    when (parameterDefinition != null)
                      root.Hint(parameterDefinition.Name.Location, "Parameter definition.");
                  }
                }
              }
            }

          | _ => ()
        }

        when (!hasUnconditionalScenario && suiteStatements.Length > 0)
          ast.Name.Error(context, "Suite must contain at least one scenario without TriggerPath attribute.", 0);
      }
      catch { | e => ast.Name.Error(context, $"Internal Compiler Error: Exception: $e.", 0); }
    }

    public ReportProductTypeFields(this ast : IAst, context : DependentPropertyEvalContext, fields : ImmutableArray[Tdl.FieldSymbol]) : void
    {
      mutable replacedWith;
      // Check required fields
      def set = HashSet(RequiredProductTypeFields);
      foreach (field in fields)
        unless (set.Remove(field.Name))
          when (ObsoleteProductTypeFields.TryGetValue(field.Name, out replacedWith))
            _ = set.Remove(replacedWith);

      unless (set.IsEmpty())
        ast.Error(context, $"Missing required fields: ..$set");

      // Check obsolete fields
      foreach (field when ObsoleteProductTypeFields.TryGetValue(field.Name, out replacedWith) in fields)
        field.FirstDeclarationOrDefault.Name.Warning(context, $"Field $(field.Name) is obsolete and will be replaced with $replacedWith field.");
    }

    public CheckTestMethods(this ast : IAst, name : IAst, context : DependentPropertyEvalContext, actions : ImmutableArray[ScenarioAction]) : void
    {
      foreach (x when x.IsTest in actions)
        return;

      name.Error(context, "Scenario must have at least one test method.");
    }

    public ReportDuplicateBarrier(this ast : IAst, context : DependentPropertyEvalContext, actions : ImmutableArray[ScenarioAction]) : void
    {
      def set = HashSet();
      foreach (b is ScenarioAction.Barrier when !set.Add(b.barrier.Id) in actions)
      {
        def loc = Location(ast.Location.Source, b.Location.StartPos, b.Location.EndPos);
        def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
        msgs.ReportMessage(CompilerMessageType.Error, loc, "Multiple usage of barrier " + b.barrier.InitialName, 0);
      }
    }

    public CheckMaxReboots(
      this ast       : IAst,
           context   : DependentPropertyEvalContext,
           actions   : ImmutableArray[ScenarioAction],
           variables : Dictionary[TypedDeclarationSymbol, Tdl.Expr] = null
    ) : void
    {
      def values = Dictionary();
      def getPropertyValue(obj : object, prop : Declarations.DeclarationSymbol) : object * ResultKind
      {
        | (prod is Product.DefSymbol, field is Tdl.FieldSymbol) =>
          def res = prod.Defs
                        .Find(d => d.Symbol.Id == field.Id)
                        .Map(d => d.Expr.Calc(values, variables, getPropertyValue))
                        .WithDefault(($"No field $(field.Name) in $(prod.Name) product.", ResultKind.Error));
          res

        | _ => ("unsuported expression", ResultKind.Error)
      }
      def error(loc : Location, msg : string) : void
      {
        def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
        msgs.Error(loc, msg);
      }
      mutable prevAction = null;
      for (mutable i = 0; i < actions.Length; ++i)
      {
        when (actions[i] is ScenarioAction.WaitForReboot(MaxRebootsCountOpt=VNone) as action)
        {
          match (prevAction)
          {
            | ScenarioAction.WaitForReboot(MaxRebootsCountOpt = VSome(maxReboots))
            | ScenarioAction.Script       (MaxRebootsCountOpt = VSome(maxReboots))
            | ScenarioAction.Config       (MaxRebootsCountOpt = VSome(maxReboots))
            | ScenarioAction.GTest        (MaxRebootsCountOpt = VSome(maxReboots))
            | ScenarioAction.Apk          (MaxRebootsCountOpt = VSome(maxReboots))
            | ScenarioAction.Marathon     (MaxRebootsCountOpt = VSome(maxReboots))
            | ScenarioAction.Method       (MaxRebootsCountOpt = VSome(maxReboots)) =>
              match (maxReboots.Calc(values, variables, getPropertyValue))
              {
                | (_,     ResultKind.Missing)           => assert(false)
                | (_,     ResultKind.NotSet)            => assert(false)
                | (_value, ResultKind.ExternalParameter)
                | (_value, ResultKind.GlobalParameter)
                | (_value, ResultKind.Product)
                | (_value, ResultKind.Error)
                | (_value, ResultKind.VmCapability)
                | (_,     ResultKind.External) => error(prevAction.Location, "This kind of expression is not allowed in max-reboots.");
                | (value : object, ResultKind.Value)             =>
                  if (value is int as intVal)
                    when (intVal < 1)
                      error(prevAction.Location, "Directive 'max-reboots' with non-zero value is required by following 'wait-for-reboot' scenario action.");
                  else
                    error(prevAction.Location, "The max-reboots should have int type.");
              }

            | _ =>
              def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
              msgs.Warning(action.Location, "Redundant 'wait-for-reboot' scenario action.");
          }
        }
        prevAction = actions[i];
      }
    }

    [Record]
    struct Edge
    {
      public From : ScenarioAction.Barrier;
      public To   : ScenarioAction.Barrier;
    }

    [Record]
    class Node[TSymbol] : GraphNodeWithConnections[Node[TSymbol]]
      where TSymbol : DeclarationSymbol
    {
      public Symbol : TSymbol;
    }

    public CheckMultiMachineScenario(this ast : IAst, context : DependentPropertyEvalContext, scenarios : ImmutableArray[ScenarioSymbol], _depend : object) : void
    {
      def edges = List();
      def nodesMap = Dictionary();
      def loop(scenario : ScenarioSymbol) : void
      {
        | Scenario.DefSymbol as d =>
          unless (d.IsActionsEvaluated)
            return;

          mutable prev;
          foreach (action is ScenarioAction.Barrier in d.Actions)
          {
            mutable node;
            unless (nodesMap.TryGetValue(action.barrier, out node))
            {
              node = Node(action.barrier);
              nodesMap.Add(action.barrier, node);
            }

            when (prev != null)
            {
              nodesMap[prev.barrier].AddConnection(node);
              edges.Add(Edge(prev, action));
            }

            prev = action;
          }

        | Scenario.SetSymbol as s =>
          unless (s.IsScenariosEvaluated)
            return;
          foreach (scenario in s.Scenarios)
            loop(scenario);
        | Scenario.GeneratorSymbol => ()
        | _ => assert(false)
      }
      foreach (scenario in scenarios)
        loop(scenario);

      def groups = GraphAlgorithms.FindStronglyConnectedComponents(nodesMap.Values);

      foreach (group in groups)
        when (group.IsNonTrivial())
        {
          def symbols = HashSet();
          foreach (node in group.Nodes)
            _ = symbols.Add(node.Symbol);

          def barrierUsages = HashSet();
          foreach (edge in edges)
          {
            when (symbols.Contains(edge.From.barrier) && symbols.Contains(edge.To.barrier))
            {
              _ = barrierUsages.Add(edge.From);
              _ = barrierUsages.Add(edge.To);
            }
          }

          def msgs               = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
          def deadLockedBarriers = group.Nodes.ToArray().Map(n => AsName(n.Symbol.Name));
          foreach (usage in barrierUsages.OrderBy(u => u.Location.Source.File).ThenBy(u => u.Location.StartPos))
            msgs.ReportMessage(CompilerMessageType.Error, usage.Location, $"Barriers deadlock detected: ..$deadLockedBarriers", 0);
        }
    }

    public GetSetScenarios(scenarioSet : Scenario.SetSymbol) : List[Scenario.DefSymbol]
    {
      GetSetScenarios(scenarioSet, null)
    }

    public GetSetScenarios(scenarioSet : Scenario.SetSymbol, duplicates : HashSet[Scenario.SetSymbol * Scenario.DefSymbol]) : List[Scenario.DefSymbol]
    {
      def result  = List();
      def visited = HashSet();
      def loop(set : Scenario.SetSymbol) : void
      {
        unless (visited.Add(set))
          return;
        unless (set.IsScenariosEvaluated)
          return;
        foreach (scenario in set.Scenarios)
        {
          | Scenario.SetSymbol as subSet                => loop(subSet)
          | Scenario.DefSymbol as d when visited.Add(d) => result.Add(d);
          | Scenario.DefSymbol as d                     => when (duplicates != null) _ = duplicates.Add((set, d))
          | Scenario.GeneratorSymbol                    => ()
          | _ => assert(false)
        }
      }
      loop(scenarioSet);
      result
    }

    public ValidateRunnerParameters(this ast : IAst, parameters : ImmutableArray[FormalParameterSymbol], context : DependentPropertyEvalContext) : void
    {
      def e = parameters.GetEnumerator();

      def loopOptionalParameters()
      {
        when (e.MoveNext())
        {
          if (e.Current.HasDefault())
            loopOptionalParameters()
          else
            (e.Current.FirstParsedDeclarationOrDefault ?? ast).Error(context, $"Parameter '$(e.Current.Name)' must have default value.")
        }
      }

      def loopRequiredParameters()
      {
        when (e.MoveNext())
        {
          if (e.Current.HasDefault())
            loopOptionalParameters();
          else
            loopRequiredParameters()
        }
      }

      loopRequiredParameters()
    }

    public ValidateRunnerArguments(this ast : IAst, parameters : ImmutableArray[FormalParameterSymbol], arguments : IAstList[RunnerArgument], context : DependentPropertyEvalContext) : void
    {
      def namedParametersUsed = HashSet();

      def requiredParameters = Dictionary();
      foreach (p when !p.HasDefault() in parameters)
        requiredParameters[p.NameId] = p.Name;

      def positionalArguments = List();
      foreach (x in arguments)
      {
        | a is RunnerArgument.Named =>
           _ = requiredParameters.Remove(a.ParameterName.Id);
          unless (namedParametersUsed.Add(a.ParameterName.Id))
            a.ParameterName.Error(context, $"Multiple runner argument specification '$(a.ParameterName.Text)'.");

        | a is RunnerArgument.Positional =>
          positionalArguments.Add(a);

        | _ => ()
      }

      def positionalParameters = List();
      foreach (p in parameters)
        unless (namedParametersUsed.Contains(p.NameId))
          positionalParameters.Add(p);

      when (positionalArguments.Count > positionalParameters.Count)
        ast.Error(context, $"Too many runner arguments, need $(parameters.Length) got $(arguments.Count).");

      for (mutable i = Math.Min(positionalParameters.Count, positionalArguments.Count) - 1; i >= 0; --i)
      {
        def parameter = positionalParameters[i];
        def argument = positionalArguments[i];
        when (!argument.IsParameterEvaluated)
          argument.Parameter = parameter;
        when (parameter.IsTypeEvaluated && !argument.Value.IsExpectedTypeEvaluated)
          argument.Value.ExpectedType = parameter.Type;
        _ = requiredParameters.Remove(parameter.NameId);
      }

      match (requiredParameters.Count)
      {
        | 0 => ()
        | 1 => ast.Error(context, $"Required runner parameter is not specified: $(requiredParameters.Values.First()).")
        | _ => ast.Error(context, $"Required runner parameters are not specified: ..$(requiredParameters.Values).")
      }
    }

    public CheckUniquenessOfScenarios(this _ast : IAst, context : DependentPropertyEvalContext, set : Scenario.SetSymbol, _depend : object) : void
    {
      def duplicates = HashSet();
      _ = GetSetScenarios(set, duplicates);
      when (duplicates.Count > 0)
      {
        def group = duplicates.GroupBy((set, _) => set);
        foreach (x in group)
        {
          foreach ((_, d) in x)
          {
            def decl = x.Key.FirstDeclarationOrDefault :> Scenario.Set;
            foreach (scenarioDecl when scenarioDecl.IsRefEvaluated && scenarioDecl.Ref.IsSymbolEvaluated in decl.Scenarios)
            {
              when (scenarioDecl.Ref.Symbol.Id == d.Id)
              {
                scenarioDecl.Error(context, "Duplicate scenario in group.");
              }
            }
          }
        }
      }
    }

    public CheckExpected(this ast : IAst, context : DependentPropertyEvalContext, type1 : TypeSymbol, type2 : TypeSymbol) : void
    {
      if (TdlTypeUnifier.Instance.TryRequire(type2, type1))
        _ = TdlTypeUnifier.Instance.Require(type2, type1);
      else
        ast.Error(context, $"Expected '$(TypeToString(type1))' but got '$(TypeToString(type2))'.", 0);
    }

    public CheckExpectedForTuple(this ast : IAst, context : DependentPropertyEvalContext, items : DefExpr.IAstList, expectedType : TypeSymbol, type : TypeSymbol) : void
    {
      match (expectedType, type)
      {
        | _ when (items.Count < 2) => ast.Error(context, "A tuple must have more than one elements.", 0);
        | (expectedTuple is TdlType.TupleSymbol, tuple2 is TdlType.TupleSymbol) =>
          def expectedArgs = expectedTuple.Args;
          def args = tuple2.Args;

          when (expectedArgs.Length != items.Count || expectedArgs.Length != args.Length)
          {
            def got = if (expectedArgs.Length == items.Count) args.Length else items.Count;
            items.Error(context, $"Expected $(expectedArgs.Length) but got $got tuple elemens.", 0);
            return;
          }

          for (mutable i = 0; i < expectedArgs.Length; i++)
          {
            def t1   = expectedArgs[i];
            def t2   = args[i];
            def item = items[i];
            if (TdlTypeUnifier.Instance.TryUnify(t1, t2))
              _ = TdlTypeUnifier.Instance.Unify(t1, t2);
            else
              item.Error(context, $"Expected '$(TypeToString(expectedType))' but got '$(TypeToString(type))'.", 0);
          }

        | _ when TdlTypeUnifier.Instance.TryRequire(type, expectedType) => _ = TdlTypeUnifier.Instance.Require(type, expectedType);
        | _ => ast.Error(context, $"Expected $(TypeToString(expectedType)) but got $(TypeToString(type)).", 0);
      }
    }

    public MakeTupleType(this context : DependentPropertyEvalContext, items : ImmutableArray[TypeSymbol]) : ValueOption[TypeSymbol]
    {
      def tuple  = TdlType.TupleSymbol();
      tuple.BaseTypeSet = BaseTypeReferenceSet(null);
      tuple.BaseTypeSet.AddParent(ToTdlContext(context).TdlProjectData.BackEnd.PlatformType.Object);
      tuple.Args = items;
      tuple.EvalProperties(context);
      VSome(tuple)
    }

    TypeToString(type : TypeSymbol) : string
    {
      | f is FunctionTypeSymbol when f.IsParametersEvaluated && f.IsReturnEvaluated && f.Parameters.Length == 0
                                  && f.Return.Name.Equals("void", StringComparison.OrdinalIgnoreCase)           => "Test method"
      | _ => type.ToString()
    }

    public MakeTuple(this context : DependentPropertyEvalContext, items : ImmutableArray[TypeSymbol]) : TypeSymbol
    {
      when (items.Length == 1)
        return items[0];

      def tuple = TdlType.TupleSymbol();
      tuple.BaseTypeSet = BaseTypeReferenceSet(null);
      tuple.BaseTypeSet.AddParent(ToTdlContext(context).TdlProjectData.BackEnd.PlatformType.Object);
      tuple.Args = items;
      tuple.EvalProperties(context);
      tuple
    }

    public MakeFroms(froms : From.IAstList) : ValueOption[ImmutableArray[Code.From]]
    {
      def builder = ImmutableArray.CreateBuilder(froms.Count);
      foreach (from in froms)
      {
        when (!from.Vars.IsSymbolEvaluated || !from.List.IsResultEvaluated)
          return VNone();

        def result = Code.From(from.Vars.Symbol, from.List.Result);
        builder.Add(result);
      }

      VSome(builder.MoveToImmutable())
    }

    public CheckOptionForDuplicates(this _ast : IAst, context : DependentPropertyEvalContext, options : ImmutableArray[Ref[TypedDeclarationSymbol]]) : void
    {
      def duplicateSet = HashSet();
      foreach (option when option.IsSymbolEvaluated in options)
      {
        def id = option.Symbol.Id;
        unless (duplicateSet.Add(id))
        {
          option.Location.Error(context, "Duplicate option.");
        }
      }
    }

    public Error(this location : Location, context : DependentPropertyEvalContext, message : string) : void
    {
        def msgs = context.GetFileData(location.Source.File.Id).GetCompilerMessage();
        msgs.ReportMessage(CompilerMessageType.Error, location, message, 0);
    }

    public MakeSelectAggregateParametersScope(scope : TableScope, deployments : ImmutableArray[ImmutableArray[DeploymentSymbol]]) : ValueOption[Scope]
    {
      def visited = HashSet();
      mutable builder = UnionScopeBuilder();
      foreach (seq in deployments)
      {
        unless (CollectDeployments(visited, ref builder, seq))
          return VNone();
      }
      VSome(builder.ToScope().HideWith(scope))
    }

    public CheckSelectDeployment(this ast : IAst, context : DependentPropertyEvalContext, cases : Case.IAstList, parameterCount : int) : void
    {
      try
      {
        def msgs = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();

        foreach (case in cases)
        {
          def isDefault = case.Values.Any(v => v.Text == Api.CaseElseValue);
          if (isDefault)
            when (case.Values.Count != 1)
            {
              msgs.ReportMessage(CompilerMessageType.Error, case.Values.Location, "Expected single 'else' keyword.", 0);
              return;
            }
          else
            when (case.Values.Count != parameterCount)
            {
              msgs.ReportMessage(CompilerMessageType.Error, case.Values.Location, $"The case must have $parameterCount values.", 0);
              return;
            }
        }

        def set = HashSet();
        foreach (case in cases with k)
        {
          def values = case.Values.Map(_.Text);
          unless (set.Add(values))
            msgs.ReportMessage(CompilerMessageType.Error, case.Values.Location, "Duplicate entry.", 0);
        }
      }
      catch { | e => Ice(ast, context, e); }
    }

    public MakeDefaultDefs(this ast : IAst, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], definitionScope : Scope, product : TypedDeclarationSymbol) : ValueOption[ImmutableArray[FormalParameterSymbol]]
    {
      def getAllProducts(product : TypedDeclarationSymbol) : Seq[Product.DefSymbol]
      {
        | Product.DefSymbol as ds => [ds]
        | Product.SetSymbol as ss => ss.AllProducts.OfType.[Product.DefSymbol]()
        | _ => assert(false);
      }

      MakeDefaultDefs(ast, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], definitionScope, product, getAllProducts)
    }

    public MakeDefaultDefs(this ast : IAst, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], definitionScope : Scope, product : TypedDeclarationSymbol, froms : ImmutableArray[Tdl.Code.From]) : ValueOption[ImmutableArray[FormalParameterSymbol]]
    {
      def getAllProducts(product : TypedDeclarationSymbol) : Seq[Product.DefSymbol]
      {
        | Product.DefSymbol as ds => [ds]
        | Product.SetSymbol as ss => ss.AllProducts.OfType.[Product.DefSymbol]()
        | VarSymbol as v =>
          foreach (from in froms)
          foreach (var when v.Id == var.Id in from.Vars with i)
          {
            def list = from.Elems.GetExprListForVar(i);
            def toSymbol(e : Expr) : ProductSymbol
            {
              | Reference(Symbol=ProductSymbol as symbol) => symbol
              | _ => null
            }
            return list.Select(toSymbol).Where(_ != null).SelectMany(getAllProducts);
          }
          []
        | _ => assert(false);
      }

      MakeDefaultDefs(ast, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], definitionScope, product, getAllProducts)
    }

    variant SelectDeploymentParameterOption
    {
      | NotSet
      | SetViaReference
      | Value { v : string }
    }

    MakeDefaultDefs(ast : IAst, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], definitionScope : Scope, product : TypedDeclarationSymbol, getAllProducts : TypedDeclarationSymbol -> Seq[Product.DefSymbol]) : ValueOption[ImmutableArray[FormalParameterSymbol]]
    {
      try
      {
        def filteringScope    = definitionScope :> FilteringScope;
        def selectParams      = HashSet(filteringScope.Scope.GetAllSymbols()
                                                      .OfType.[FormalParameterSymbol]()
                                                      .Where(p => p.IsDeclaredInEvaluated && p.DeclaredIn is Deployment.SelectSymbol));

        when (selectParams.Count == 0)
          return VSome(ImmutableArray.Empty);

        def selectDeployments = HashSet(selectParams.Select(p => p.DeclaredIn :> Deployment.SelectSymbol));
        def paramMap          = Dictionary.[DeclarationSymbol, SelectDeploymentParameterOption](ParameterComparer.Instance);

        // We fill the values explicitly specified.
        foreach (d in defs)
            match (d.Expr)
            {
              | Tdl.Expr.String as str => paramMap[d.Symbol] = SelectDeploymentParameterOption.Value(str.Value);
              | Tdl.Expr.Reference     => paramMap[d.Symbol] = SelectDeploymentParameterOption.SetViaReference();
              | Tdl.Expr.MemberAccess  => paramMap[d.Symbol] = SelectDeploymentParameterOption.SetViaReference();
              | _ => ()
            }

        foreach (ds in getAllProducts(product)) // TODO: вычислить продукты сразу, так как они на первом проходе не вычисленны и остальные вычисления делать бессмысленно.
        {
          unless (ds.IsDefsEvaluated)
            return VNone();

          foreach (d in ds.Defs)
            match (d.Expr)
            {
              | Tdl.Expr.String as str => paramMap[d.Symbol] = SelectDeploymentParameterOption.Value(str.Value);
              | Tdl.Expr.Reference     => paramMap[d.Symbol] = SelectDeploymentParameterOption.SetViaReference();
              | Tdl.Expr.MemberAccess  => paramMap[d.Symbol] = SelectDeploymentParameterOption.SetViaReference();
              | _ => ()
            }
        }

        foreach (selectDeployment in selectDeployments)
        {
          unless (selectDeployment.IsParametersEvaluated)
            return VNone();

          def len    = selectDeployment.Parameters.Length;
          def names  = array(len);
          def values = array(len);

          foreach (p in selectDeployment.Parameters with k)
          {
            names[k] = p.Name;
            unless (paramMap.TryGetValue(p, out values[k]))
              values[k] = SelectDeploymentParameterOption.NotSet();
          }

          unless (selectDeployment.IsCasesEvaluated)
            return VNone();

          mutable isEntryMatch;
          foreach (entry in selectDeployment.Cases)
          {
            when (entry.Length != values.Length)
              return VSome(ImmutableArray.Empty); // An error message has already been reported.

            isEntryMatch = true;
            for (mutable i = 0; i < values.Length && isEntryMatch; i++)
            {
              isEntryMatch &=
                match (values[i])
                {
                  | NotSet          => entry[i] == Tdl.Expr.NotSetValue
                  | SetViaReference => true
                  | Value(text)     => entry[i] == text || entry[i] == Api.CaseElseValue
                };
            }
            when (isEntryMatch)
              break;
          }

          unless (isEntryMatch)
          {
            def notSetVar = List();
            def entryStr = List();
            for (mutable i = 0; i < names.Length; i++)
            {
              match (values[i])
              {
                | NotSet          => entryStr.Add("not-set"); notSetVar.Add("\"" + names[i] + "\"");
                | SetViaReference => entryStr.Add("_");
                | Value(text)     => entryStr.Add("\"" + text + "\"");
              }
            }

            def msgs          = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
            def suffix        = if (notSetVar.Count > 1) "s" else "";
            def notSetVarText = if (notSetVar.Count > 0) $"Variable$suffix: ..$notSetVar not set. And the" else "The";
            using (root = msgs.ReportRootMessage(CompilerMessageType.Error, ast.Location, $"$notSetVarText \"$(selectDeployment.Name)\" select deployment has no ..$entryStr entry.", 0))
              root.ReportMessage(CompilerMessageType.Hint, selectDeployment.FirstDeclarationOrDefault.Name.Location, "The related select deployment.", 0);
            return VSome(ImmutableArray.Empty);
          }
        }

        def distinctSelectParams = HashSet(selectParams, ParameterComparer.Instance);

        def builder = ImmutableArray.CreateBuilder(distinctSelectParams.Count);
        foreach (p when !paramMap.ContainsKey(p) in distinctSelectParams)
          builder.Add(p);

        VSome(builder.ToImmutable())
      }
      catch { | e => Ice(ast, context, e); VNone() }
    }

    Ice(ast : IAst, context : DependentPropertyEvalContext, e : Exception) : void
    {
      ast.Error(context, "Internal compiler error. Notify TDL developers about it: " + e);
    }

    public AsName(text : string) : string
    {
      foreach (ch when char.IsWhiteSpace(ch) in text)
        return "\"" + text + '"';

      text
    }

    public SetSpecialDeployment(this modifier : DeploymentModifier, symbol : DeploymentSymbol, context : DependentPropertyEvalContext) : void
    {
      def context = context.ToTdlContext();
      match (modifier)
      {
        | DeploymentModifier.Initial with (get = context.get_InitialDeployment, set = context.set_InitialDeployment, specialType = "initial")
        | DeploymentModifier.Final   with (get = context.get_FinalDeployment,   set = context.set_FinalDeployment,   specialType = "final") =>
          SetUsed(modifier, symbol, true);

          def specialDeployment = get();
          if (specialDeployment == null)
            set(symbol)
          else
          {
            def msgs = CompilerMessagesExtensions.GetCompilerMessage(context, modifier);
            using (root = msgs.RootError(modifier, $"Redefinition of $specialType deployment, first is '$(specialDeployment)'."))
            {
              def firstDefinition = specialDeployment.FirstParsedDeclarationOrDefault;
              when (firstDefinition != null)
                root.Hint(firstDefinition.Name.Location, "First definition.");
            }
          }

        | DeploymentModifier.Export =>
          SetUsed(modifier, symbol, true);
          _ = context.ExportDeployments.Add(symbol);

        | _ => assert2(false, $"Unknown deployment mofidifier of type $(modifier.GetType())");
      }
    }

    public ValidateExportParameters(this ast : DeploymentModifier.Export, symbol : DeploymentSymbol, parametersScope : Scope,
      bindedParameters : ImmutableArray[Ref[DeclarationSymbol]], context : DependentPropertyEvalContext) : void
    {
      def msgs = CompilerMessagesExtensions.GetCompilerMessage(context, ast);
      match (symbol)
      {
        | Deployment.SetSymbol
        | Deployment.SelectSymbol
        | Deployment.CurryingSymbol =>
          def referencedSymbols = HashSet();
          foreach (r when (r.IsSymbolEvaluated) in bindedParameters)
            unless (referencedSymbols.Add(r.Symbol))
              msgs.Error(r, $"Duplicated reference of export parameter $(r.Name)");

          def missedSymbols = SortedSet();
          foreach (parameterSymbol when (!referencedSymbols.Contains(parameterSymbol)) in parametersScope.GetAllSymbols())
            _ = missedSymbols.Add(parameterSymbol.Name);

          when (missedSymbols.Count > 0)
            msgs.Error(ast, $"Export parameters clause is missing following parameters: ..$(missedSymbols).");

        | Deployment.ScriptSymbol
        | Deployment.CodeSymbol
        | Deployment.ImportSymbol
        | Deployment.EmptySymbol =>
          when (ast.Parameters.Count > 0)
            msgs.Error(ast.Parameters, "Export parameters clause is redundant.");

        | s => assert(false, $"Unknown deployment symbol $s");
      }
    }

    public CheckForRecursionSuite(this ast : IAst, context : DependentPropertyEvalContext, symbol : SuiteSymbol, _depend : object) : void
    {
      def getDescendants(sym : SuiteSymbol) : Seq[SuiteSymbol]
      {
          | _ is Suite.GeneratorSymbol
          | _ is Suite.DefSymbol  => []
          | s is Suite.ListSymbol => if (s.IsSuitesEvaluated) s.Suites else []
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      _ = CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }

    public CheckForRecursionProduct(this ast : IAst, context : DependentPropertyEvalContext, symbol : ProductSymbol, _depend : object) : void
    {
      def getDescendants(sym : ProductSymbol) : Seq[ProductSymbol]
      {
          | _ is Product.DefSymbol => []
          | s is Product.SetSymbol => if (s.IsProductsEvaluated) s.Products else []
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      _ = CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }

    public CheckForRecursionScenario(ast : IAst, context : DependentPropertyEvalContext, symbol : ScenarioSymbol, _depend : object) : ImmutableArray[ScenarioSymbol]
    {
      def getDescendants(sym : ScenarioSymbol) : Seq[ScenarioSymbol]
      {
          | _ is Scenario.DefSymbol   => []
          | s is Scenario.SetSymbol      => if (s.IsScenariosEvaluated) s.Scenarios else []
          | _ is Scenario.GeneratorSymbol => [] //
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }

    public CheckForRecursionDeployment(this ast : IAst, context : DependentPropertyEvalContext, symbol : DeploymentSymbol, _depend : object) : ImmutableArray[DeploymentSymbol]
    {
      def getDescendants(sym : DeploymentSymbol) : Seq[DeploymentSymbol]
      {
          | _ is Deployment.ScriptSymbol   => []
          | _ is Deployment.CodeSymbol     => []
          | _ is Deployment.ImportSymbol   => []
          | s is Deployment.SetSymbol      => if (s.IsDeploymentsEvaluated)    s.Deployments      else []
          | s is Deployment.SelectSymbol   => if (s.IsDeploymentsEvaluated)    s.Deployments.SelectMany(x => x) else []
          | s is Deployment.CurryingSymbol => if (s.IsBaseDeploymentEvaluated) [s.BaseDeployment] else []
          | _ is DeploymentRebootSymbol    => []
          | _ is Deployment.EmptySymbol    => []
          | s => assert(false, "Unsupported symbol type: " + s.GetType().FullName)
      }
      CheckForRecursion(ast, context, symbol, getDescendants, _depend)
    }

    public CheckForRecursion[TSymbol](ast : IAst, context : DependentPropertyEvalContext, symbol : TSymbol, getDescendants : TSymbol -> Seq[TSymbol], _depend : object) : ImmutableArray[TSymbol]
      where TSymbol: DeclarationSymbol
    {
      def nodesMap = Dictionary();
      def loop(parentNode : Node[TSymbol], sym : TSymbol) : void
      {
        def nodesMap = nodesMap;
        mutable node;
        unless (nodesMap.TryGetValue(sym, out node))
        {
          node = Node(sym);
          nodesMap.Add(sym, node);

          def descendants = getDescendants(sym).ToArray();
          foreach (subSym in descendants)
            loop(node, subSym);
        }

        when (parentNode != null)
          node.AddConnection(parentNode);
      }

      loop(null, symbol);

      def nodesMap = nodesMap;
      def groups = GraphAlgorithms.FindStronglyConnectedComponents(nodesMap.Values);

      foreach (group when group.IsNonTrivial() in groups)
      {
        def names = group.Nodes.ToArray().Map(n => AsName(n.Symbol.Name));
        def msg   = if (group.Nodes.Count == 1) $"$(names[0]) is cycled." else $"Detected a cycle between: ..$names.";
        def msgs  = context.GetFileData(ast.Location.Source.File.Id).GetCompilerMessage();
        foreach (node in group.Nodes)
        {
          def sym  = node.Symbol;
          def decl = sym.FirstDeclarationOrDefault;
          def loc  = decl.Name.Location;
          msgs.ReportMessage(CompilerMessageType.Error, loc, msg, 0);
        }
      }

      nodesMap.Keys.ToImmutableArray()
    }

    public SetUsed(this _ast : IAst, symbol : DeclarationSymbol, isUsed : bool) : void
    {
      when (symbol is UsedDeclarationSymbol as usageSymbol when !usageSymbol.IsIsUsedEvaluated)
        usageSymbol.IsUsed = isUsed;
    }

    public SetUsed[T](this _ast : IAst, items : Seq[T], isUsed : bool) : void
      where T: UsedDeclarationSymbol
    {
      foreach (item when !item.IsIsUsedEvaluated in items)
        item.IsUsed = isUsed;
    }

    public SetUsed(this _ast : IAst, statements : Seq[SuiteStatement]) : void
    {
      foreach (statement in statements)
      {
        | CallScenario as s => unless (s.Reference.IsIsUsedEvaluated) s.Reference.IsUsed = true;
      }
    }

    public GetScenarioDeployments(deployment : TypedDeclarationSymbol, froms : ImmutableArray[Code.From], context : DependentPropertyEvalContext) : Seq[DeploymentSymbol]
    {
      def tdlContext = context.ToTdlContext();

      def initialDeployment = tdlContext.InitialDeployment;
      when (initialDeployment != null)
        yield initialDeployment;

      match (deployment)
      {
        | DeploymentSymbol as d => yield d;
        | VarSymbol as v =>
          foreach (from in froms)
          foreach (var when v.Id == var.Id in from.Vars with i)
          {
            def list = from.Elems.GetExprListForVar(i);
            foreach (x in list)
            {
              | Reference(Symbol=DeploymentSymbol as d) => yield d;
              | _ => ()
            }
            break;
          }
        | _ => assert(false, $"Unsupported expression type $(deployment.GetType().FullName)");
      }

      def finalDeployment = tdlContext.FinalDeployment;
      when (finalDeployment != null)
        yield finalDeployment;
    }

    public MakeDefinitionScopeForScenario(deployment : TypedDeclarationSymbol, froms : ImmutableArray[Code.From], context : DependentPropertyEvalContext) : ValueOption[Scope]
    {
      match (MakeAggregateParametersScope(GetScenarioDeployments(deployment, froms, context), GetVmCapabilityScope(context)))
      {
        | VSome(scope) => VSome(GetScenarioParameterScope(context).HideWith(scope))
        | VNone => VNone()
      }
    }

    public MakeAggregateParametersScopeForScenario(parametersScope : Scope, deployment : TypedDeclarationSymbol, froms : ImmutableArray[Code.From], context : DependentPropertyEvalContext, defs : ImmutableArray[Tdl.Def]) : ValueOption[Scope]
    {
      match (MakeAggregateParametersScope(GetScenarioDeployments(deployment, froms, context), parametersScope))
      {
        | VSome(scope) => VSome(FilterOutAssignedParameters(scope, defs))
        | VNone => VNone()
      }
    }

    private FilterOutAssignedParameters(scope : Scope, defs : ImmutableArray[Tdl.Def]) : Scope
    {
      def assignedParams = HashSet();
      foreach (d in defs)
        _ = assignedParams.Add(GetCaseInsensitiveId(d.Symbol));

      scope
        .FilterWith(symbol => !assignedParams.Contains(GetCaseInsensitiveId(symbol)))
        .Memoize()
    }

    //public ToInt(this maxRebootsCountOpt : OptionParseTree[GrammarParseTree.MaxRebootsCount]) : ParsedValue[int]
    //{
    //  unless (maxRebootsCountOpt.HasValue)
    //    return ParsedValue(maxRebootsCountOpt.Span.StartPos);
    //
    //  def lit = maxRebootsCountOpt.Value.Value;
    //
    //  when (lit.IsMissing || lit.IsAmbiguous)
    //    return ParsedValue(lit.Span.StartPos);
    //
    //  ParsedValue(lit.Span, int.Parse(lit.GetText()))
    //}

    public ToBool(this continueOnErrorOpt : OptionParseTree[GrammarParseTree.ContinueOnError]) : ParsedValue[bool]
    {
      if (continueOnErrorOpt.HasValue)
        ParsedValue(continueOnErrorOpt.Span, true)
      else
        ParsedValue(continueOnErrorOpt.Span.StartPos)
    }

    public ResolveOpt[TSymbol](this refOpt : ValueOption[Ref[DeclarationSymbol]]) : ValueOption[Ref[TSymbol]]
      where TSymbol: DeclarationSymbol
    {
      if (refOpt.HasValue) VSome(refOpt.Value.Resolve.[TSymbol]()) else VNone()
    }

    public GetSymbolOpt[TSymbol](this refOpt : ValueOption[Ref[TSymbol]]) : ValueOption[TSymbol]
      where TSymbol: DeclarationSymbol
    {
      if (refOpt.HasValue && refOpt.Value.IsSymbolEvaluated) VSome(refOpt.Value.Symbol) else VNone()
    }

    public IncrementGuid(guid : Guid, value : uint) : Guid
    {
      def bytes1   = guid.ToByteArray();
      def version  = BitConverter.ToUInt32(bytes1, 0) + value;
      def bytes2   = BitConverter.GetBytes(version);
      bytes1[0] = bytes2[0];
      bytes1[1] = bytes2[1];
      bytes1[2] = bytes2[2];
      bytes1[3] = bytes2[3];
      Guid(bytes1)
    }

    public NewGuid(this context : DependentPropertyEvalContext) : Guid
    {
      def data = context.ToTdlContext().TdlProjectData;
      if (data.IsTestMode)
        IncrementGuid(BaseStableGuid, data.GetStableGuidIncrementalValue());
      else
        Guid.NewGuid()
    }

    [Record]
    private class AstVisitor : IAstVisitor
    {
      public this(onName : Name -> void, onReference : Reference -> void) { _onReference = onReference; _onName = onName; }

      private _onReference : Reference -> void;
      private _onName      : Name      -> void;
      private _onIRef      : IRef      -> void;
      private _onIAst      : IAst      -> void;

      public Visit(ast : IAst)  : void
      {
        when (_onIAst != null)
          _onIAst(ast);

        ast.Accept(this)
      }
      public Visit(r : IRef)    : void
      {
        when (_onIRef != null)
          _onIRef(r);
      }
      public Visit(name : Name) : void implements IAstVisitor.Visit
      {
        when (_onName != null)
          _onName(name);
      }
      public Visit(reference : Reference) : void implements IAstVisitor.Visit
      {
        when (_onReference != null)
          _onReference(reference);
      }
    }

    public Accept(this ast : IAst, onName : Name -> void, onReference : Reference -> void) : void
    {
      ast.Accept(AstVisitor(onName, onReference));
    }

    //public CreateLoginAction(context : DependentPropertyEvalContext, location : Location, user : Tdl.Expr, password : Tdl.Expr) : ScenarioAction.Login
    //{
    //  def userValue     = ConvertStringLiteral(user);
    //  def passwordValue = ConvertStringLiteral(password);
    //
    //  when (string.IsNullOrEmpty(userValue.Value))
    //    user.Error(context, "User name must be non empty string.");
    //
    //  ScenarioAction.Login(location, userValue, passwordValue)
    //}

    public ValidateCommandParameters(this ast : CommandCall, command : DeclaredTypeSymbol, context : DependentPropertyEvalContext) : void
    {
      def projectData = ToTdlContext(context).TdlProjectData;
      def usedParameters = Dictionary();

      foreach (argument in ast.Arguments)
      {
        def name         = argument.ParameterName;
        def expectedKind =
          match (argument)
          {
            | CommmandCallInputArgument =>
              mutable initialLocation;
              if (usedParameters.TryGetValue(name.Id, out initialLocation))
              {
                def msgs = CompilerMessagesExtensions.GetCompilerMessage(context, ast);
                using (root = msgs.RootError(name, $"Duplicated assignment of command parameter '$(name.Text)'."))
                  root.Hint(initialLocation, "First assignment.");
              }
              else
                usedParameters.Add(name.Id, name.Location);
              CommandSymbolKind.Input

            | CommmandCallOutputArgument => CommandSymbolKind.Output
            | _                          => CommandSymbolKind.None
          };

        when (expectedKind != CommandSymbolKind.None && argument.IsPropertyRefEvaluated && argument.PropertyRef.IsSymbolEvaluated)
        {
          def kind = projectData.GetCommandSymbolKind(argument.PropertyRef.Symbol);
          when ((kind & expectedKind) == 0)
          {
            def action = if (expectedKind == CommandSymbolKind.Output) "readable" else "writable";
            name.Error(context, $"Command parameter '$(name)' is not $(action).");
          }
        }
      }

      mutable requiredParameters;
      foreach ((s, kind) in projectData.GetCommandParameters(command))
      {
        when ((kind & CommandSymbolKind.InputRequired) == CommandSymbolKind.InputRequired && !usedParameters.ContainsKey(s.NameId))
        {
          when (requiredParameters == null)
            requiredParameters = List();
          requiredParameters.Add("'" + s.Name + "'");
        }
      }

      when (requiredParameters != null)
      {
        def (p1, p2) = if (requiredParameters.Count == 1) ("parameter", "is") else ("parameters", "are");
        ast.Error(context, $<#Required command $(p1) ..$(requiredParameters; ", ") $(p2) not assigned.#>)
      }
    }

    public BuildInvocationScope(this context : DependentPropertyEvalContext, globalScope : Scope) : InvocationScopeBuilder
    {
      InvocationScope(_, _, globalScope, context)
    }

    //public RequiredTypeParam1(this ast : IAst, context : DependentPropertyEvalContext, type : TypeSymbol, baseTypeFullTypeName : string, baseTypeParam : TypeSymbol) : TypeSymbol
    //{
    //  def baseType = context.ConstructType(baseTypeFullTypeName, baseTypeParam);
    //  Require(ast, context, type, baseType);
    //  baseTypeParam
    //}

    public ProvidedTypeParam1(this ast : IAst, context : DependentPropertyEvalContext, type : TypeSymbol, derivedTypeFullTypeName : string, derivedTypeParam : TypeSymbol) : TypeSymbol
    {
      def derivedType = context.ConstructType(derivedTypeFullTypeName, derivedTypeParam);
      Provide(ast, context, type, derivedType);
      derivedTypeParam
    }

    //public Require(this ast : IAst, context : DependentPropertyEvalContext, type1 : TypeSymbol, baseTypeFullTypeName : string, baseTypeParam : TypeSymbol) : void
    //{
    //  def baseType = context.ConstructType(baseTypeFullTypeName, baseTypeParam);
    //  Require(ast, context, type1, baseType)
    //}
    //
    //public Provide(this ast : IAst, context : DependentPropertyEvalContext, type1 : TypeSymbol, derivedFullTypeName : string, derivedTypeParam : TypeSymbol) : void
    //{
    //  def derivedType = context.ConstructType(derivedFullTypeName, derivedTypeParam);
    //  Provide(ast, context, type1, derivedType)
    //}

    public SubtypeUnifyOf[T1, T2](this subtype : T1, supertype : T2) : bool
      where T1: class, TypeSymbol
      where T2: class, TypeSymbol
    {
      assert2(subtype != null, "Symbol of type " + typeof(T1).Name + " is null!");
      assert2(supertype != null, "Symbol of type " + typeof(T2).Name + " is null!");
      TypeUnifier.Instance.SubtypeUnify(subtype, supertype)
    }

    public Require(this ast : IAst, context : DependentPropertyEvalContext, type : TypeSymbol, baseTypeConstraint : TypeSymbol) : void
    {
      unless (TdlTypeUnifier.Instance.TryRequire(type, baseTypeConstraint))
        ast.Error(context, $"$(Esc(type)) is not subtype of $(Esc(baseTypeConstraint))");
      _ = TdlTypeUnifier.Instance.Require(type, baseTypeConstraint);
    }

    public Provide(this ast : IAst, context : DependentPropertyEvalContext, type : TypeSymbol, derivedType : TypeSymbol) : void
    {
      unless (TdlTypeUnifier.Instance.TryProvide(type, derivedType))
        ast.Error(context, $"$(Esc(type)) is not derived from $(Esc(derivedType))");
      _ = TdlTypeUnifier.Instance.Provide(type, derivedType);
    }

    public ConstructType(this context : DependentPropertyEvalContext, fullTypeName : string, typeParam : TypeSymbol) : TypeSymbol
    {
      def typeInfo = context.BindType(fullTypeName : string, 1);
      def type = TopConstructedTypeSymbol();
      type.TypeInfo = typeInfo;
      type.Args = ImmutableArray.Create(typeParam);
      type.EvalProperties(context);
      type
    }

    public BindType[TSymbol](this context : DependentPropertyEvalContext, fullTypeName : string, typeParamCount : int = 0) : TSymbol
      where TSymbol: DeclarationSymbol
    {
      def bindNs(scope : Scope, name : string) : Ref[NamespaceSymbol]
      {
        //assert2(false);
        def res = Reference(Location.Default, name).Bind.[NamespaceSymbol](scope);
        assert2(!res.IsUnresolved, $"Unresolved '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
        assert2(!res.IsAmbiguous, $"Ambiguous '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
        assert2(res.Symbols.Length == 1);
        res
      }
      def bindType(scope : Scope, name : string) : TSymbol
      {
        def res = Reference(Location.Default, name).Bind.[TSymbol](scope);
        assert2(!res.IsUnresolved, $"Unresolved '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
        assert2(!res.IsAmbiguous, $"Ambiguous '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
        when (typeParamCount > 0)
        {
          foreach (symbol is GenericTypeSymbol when symbol.TypeParametersCount == typeParamCount in res.Symbols)
            return (symbol : object) :> TSymbol;
        }
        assert2(res.Symbols.Length == 1, $"Ambiguous '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
        res.Symbol
      }
      def data  = context.Project.Data :> DotNetProjectData;
      def names = fullTypeName.SplitToList('.');
      def loop(scope : Scope, names) : TSymbol
      {
        match (names)
        {
          | name :: []    => bindType(scope, name)
          | name :: rest  =>
            def r = bindNs(scope, name);
            assert2(!r.IsUnresolved, $"Unresolved '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
            assert2(!r.IsAmbiguous, $"Ambiguous '$name' in '$fullTypeName'. Perhaps you have problems with reference to the assembly where this type is defined.");
            loop(r.Symbol.Scope, rest)
          | _             => assert(false);
        }
      }
      loop(data.RootNamespace.Scope, names)
    }

    public UpdateDefaultValues(this _ast : ProductType, context : DependentPropertyEvalContext, defs : ImmutableArray[Def], memberScope : TableScope, globalScope : Scope) : void
    {
      foreach (Def(Symbol=FieldSymbol(IsValueEvaluated=false) as fld, Expr=e) in defs)
        fld.Value = VSome(e);

      foreach (FieldSymbol(IsValueEvaluated=false, Name="Platforms") as fld in memberScope.GetAllSymbols())
        fld.Value = VSome(Tdl.Expr.List(globalScope.GetAllSymbols().OfType.[PlatformSymbol]().Select(p => Tdl.Expr.Reference(p)).ToImmutableArray(), GetPlatformTypeSymbol(context)));
    }

    public DefinePredefinedFields(this _ast : ProductType, context : DependentPropertyEvalContext, table : TableScope) : void
    {
      def collectionName = "System.Collections.Generic.IReadOnlyList";
      def name = "Platforms";
      def name = Name(Location.Default, name);
      def prop = ExternalDeclaration.[Tdl.FieldSymbol](name).DefineSymbol(table);
      def flags = ModifierSet(context);
      flags.Add(Modifiers.Public);
      def type = context.ConstructType(collectionName, GetPlatformTypeSymbol(context));
      prop.Type = type;

      prop.EvalProperties(context);
    }

    public DefinePredefinedFields(this _ast : SuiteType, context : DependentPropertyEvalContext, table : TableScope) : void
    {
      //def baseSuiteType = SuiteTypeSymbol();
      //def baseTypeSet = BaseTypeReferenceSet(context);
      //baseTypeSet.AddParent();
      //symbol.BaseTypeSet = baseTypeSet;
      def collectionName = "System.Collections.Generic.ICollection";
      def name = "Products";
      def name = Name(Location.Default, name);
      def prop = ExternalDeclaration.[Member.PropertySymbol](name).DefineSymbol(table);
      def flags = ModifierSet(context);
      flags.Add(Modifiers.Public);
      prop.Flags = flags;
      prop.Type = context.ConstructType(collectionName, GetProductTypeSymbol(context));
      prop.CustomAttributes = array(0);
      prop.EvalProperties(context);

      def name = "Platforms";
      def platformType = context.GetPlatformTypeSymbol();
      def name = Name(Location.Default, name);
      def prop = ExternalDeclaration.[Member.PropertySymbol](name).DefineSymbol(table);
      def flags = ModifierSet(context);
      flags.Add(Modifiers.Public);
      prop.Flags = flags;
      prop.Type = context.ConstructType(collectionName, platformType);
      prop.CustomAttributes = array(0);
      prop.EvalProperties(context);
    }

    public ConstructFromListExpectedType(this context : DependentPropertyEvalContext, list : Expr, type : TypeSymbol) : TypeSymbol
    {
      match (list)
      {
        | Expr.Reference(Symbol=Product.SetSymbol as set) => _ = Unify(set.Type, type); set.Type
        | Expr.Reference(Symbol=Platform.SetSymbol as set) => _ = Unify(set.Type, type); set.Type
        | _ => context.ConstructType("System.Collections.Generic.IEnumerable", type)
      }
    }

    public Esc(this self : TypeSymbol) : string
    {
      HintML.XmlEscape(self.ToString())
    }

    public GetType(this context : DependentPropertyEvalContext, fullName : string) : TypeSymbol
    {
      context.BindType(fullName, 0)
    }

    public MakeType(this context : DependentPropertyEvalContext, symbol : DeclarationSymbol) : ValueOption[TypeSymbol]
    {
      match (symbol)
      {
        | TypedDeclarationSymbol as t  when !t.IsTypeEvaluated => VNone()
        | TypedDeclarationSymbol as t => VSome(t.Type)
        | TypeSymbol => VSome(context.ToTdlContext().TypeType)
        | NamespaceSymbol as ns when !ns.IsScopeEvaluated => VNone()
        | NamespaceSymbol as ns =>
          def type = SelfTypeBaseSymbol();
          type.Kind = "namespace";
          type.Scope = ns.Scope;
          type.EvalProperties(context);
          VSome(type)

        | _ => VNone()
      }
    }

    //public MakeMethodAction(methodAst : QualifiedReference, methodSymbol : Member.MethodSymbol, maxRebootsCountOpt : ValueOption[Tdl.Expr],
    //  binariesFolderOpt : ValueOption[Tdl.Expr], continueOnErrorOpt : ValueOption[Tdl.Expr]) : ValueOption[ScenarioAction.Method]
    //{
    //  match (methodAst)
    //  {
    //    | Qualified as q when q.Qualifier.IsRefEvaluated && q.Qualifier.Ref.IsSymbolEvaluated =>
    //      VSome(ScenarioAction.Method(methodAst.Location,
    //                                  q.Qualifier.Ref.Symbol,
    //                                  methodSymbol,
    //                                  maxRebootsCountOpt,
    //                                  binariesFolderOpt.ConvertStringLiteral(),
    //                                  continueOnErrorOpt))
    //    | _ => VNone()
    //  }
    //}

    public HasDashboardVisible(attributes : DotNet.CustomAttributeReference.IAstList) : bool
    {
      attributes.Any(x => x.Name.IsRefEvaluated && x.Name.Ref.IsSymbolEvaluated && x.Name.Ref.Symbol is PredefinedAttributes.DashboardVisibleSymbol)
    }

    public ProductScopeFilter(scope : Scope) : Scope
    {
      def filter(symbol : DeclarationSymbol) : bool
      {
        symbol is Tdl.VarSymbol || symbol is Tdl.ProductSymbol
      }
      scope.FilterWith(filter)
    }

    public ScenarioMakeHint(symbolCache : ISymbolCache, symbol : Scenario.DefSymbol) : string
    {
      def builder = StringBuilder();
      try
      {
        symbolCache?.CacheSymbol(symbol);
        _ = builder.Append("<keyword>").HintMlEscape(symbol.Kind).Append("</keyword> ")
          .SymbolToHintMlWithSubHint(symbol)
          .AppendLine();

        def project = symbolCache :> Project;
        def id = symbol.Id;

        def rootNs = (project.Data :> TdlProjectData).RootNamespace;

        def symbols = rootNs.MemberTable.GetAllSymbols().ToArray();
        def suites = symbols
          .OfType.[Suite.DefSymbol]()
          .Where(s => s.Statements.Any(st => (st :> SuiteStatement.CallScenario).Reference.AllScenarios.Any(sc => sc.Id == id)))
          .ToList();

        if (suites.Count == 0)
          _ = builder.Append(<#Данный сценарий не используется из ни в одном suite-е.#>);
        else
        {
          def maxDisplyCount = 20;
          _ = builder.Append("Данный сценарий используется из следующих suite-ов:<br/>   ");
          _ = builder.Join(suites.Take(maxDisplyCount), HintML.SymbolToHintMlWithSubHint(_, _));
          when (suites.Count > maxDisplyCount)
            _ = builder.Append($<#Deployment is used in $(suites.Count) scenarios.#>);
        }

        _ = builder.MakeLocations(symbol);
      }
      catch { e => _ = builder.HintMlException(e); }
      builder.ToString()
    }

    public GetTriggerPaths(ast : DotNet.CustomAttributeReference.IAstList, context : DependentPropertyEvalContext) : ImmutableHashSet[TriggerPath]
    {
      def builder = ImmutableHashSet.CreateBuilder();

      def isValidPath(path)
      {
        Directory.Exists(path) || File.Exists(path)
      }

      def processExcludes(path, args) : list[string]
      {
        when (args == null || args.Count == 0)
          return [];

        def excludes = SortedSet();
        foreach (x in args)
        {
          | DotNet.Expr.Argument(Expr = DotNet.Expr.String as text) =>
            def rawValue = ConvertStringLiteral(text.Value);
            if (!rawValue.HasValue || string.IsNullOrEmpty(rawValue.Value))
              x.Error(context, "Non empty string required.");
            else
            {
              def fullPath = Path.Combine(path, rawValue.Value);
              unless (isValidPath(fullPath))
                x.Error(context, $"Excluded trigger path '$(fullPath)' not found.");
              _ = excludes.Add(rawValue.Value);
            }

          | _ => x.Error(context, "String literal expected.", 0);
        }
        NList.ToList(excludes)
      }

      def processArguments(args) : void
      {
        | [] => ()
        | DotNet.Expr.Argument(Expr = DotNet.Expr.String as text) as x ::
          DotNet.Expr.Argument(Expr = DotNet.Expr.Invocation(Left = DotNet.Expr.SimpleName as name, Arguments = excludes)) :: other
          when (name.Reference.Text == "Exclude")
        | DotNet.Expr.Argument(Expr = DotNet.Expr.String as text) as x :: other with excludes = null =>
          def rawValue = ConvertStringLiteral(text.Value);
          if (!rawValue.HasValue || string.IsNullOrEmpty(rawValue.Value))
            x.Error(context, "Non empty string required.");
          else
          {
            try
            {
              def path     = ExpandPathRelativeToAst(text, rawValue.Value);
              def excludes =
                if (isValidPath(path))
                  processExcludes(path, excludes)
                else
                {
                  x.Error(context, $"Trigger path '$(path)' not found.");
                  []
                };
              _ = builder.Add(TriggerPath(path, excludes));
            }
            catch
            {
              | e is Exception => x.Error(context, $"Failed to process trigger path ($(e.GetType())): $(e.Message)")
            }
          }
          processArguments(other);

        | x :: other =>
          x.Error(context, "String literal expected.", 0);
          processArguments(other);
      }

      foreach (r when r.IsSymbolEvaluated && r.Symbol is PredefinedAttributes.TriggerPathSymbol in ast)
        processArguments(NList.ToList(r.Arguments));

      builder.ToImmutable()
    }

    public GetTriggerPaths(mutable triggerPaths : ImmutableHashSet[TriggerPath], scenarios : ImmutableArray[ScenarioSymbol]) : ValueOption[ImmutableArray[TriggerPath]]
    {
      foreach (s in scenarios)
      {
        unless (s.IsTriggerPathsEvaluated)
          return VNone();

          triggerPaths = triggerPaths.Union(s.TriggerPaths);
      }
      VSome(triggerPaths.ToImmutableArray())
    }

    public GetIsUnconditional(triggerPaths : ImmutableHashSet[TriggerPath], scenarios : ImmutableArray[ScenarioSymbol]) : ValueOption[bool]
    {
      when (triggerPaths.IsEmpty)
      {
        foreach (s in scenarios)
        {
          unless (s.IsIsUnconditionalEvaluated)
            return VNone();

          when (s.IsUnconditional)
            return VSome(true);
        }
      }
      VSome(false)
    }

    public GetDashboardVisibleParameters(parameters : ImmutableArray[DotNet.FormalParameterSymbol], baseSymbols : Seq[DeploymentSymbol] = null) : ValueOption[ImmutableArray[DeclarationSymbol]]
    {
      GetDashboardVisibleParameters(parameters, baseSymbols,
        fun (d) { if(d.IsDashboardVisibleParametersEvaluated) VSome(d.DashboardVisibleParameters) else VNone() })
    }

    public GetDashboardVisibleParameters(parameters : ImmutableArray[DotNet.FormalParameterSymbol], baseSymbols : Seq[ScenarioSymbol]) : ValueOption[ImmutableArray[DeclarationSymbol]]
    {
      GetDashboardVisibleParameters(parameters, baseSymbols,
        fun (d) { if(d.IsDashboardVisibleParametersEvaluated) VSome(d.DashboardVisibleParameters) else VNone() })
    }

    private GetDashboardVisibleParameters[T](parameters : ImmutableArray[DotNet.FormalParameterSymbol], baseSymbols : Seq[T],
      getDashboardVisisbleSymbols : T -> ValueOption[ImmutableArray[DeclarationSymbol]]) : ValueOption[ImmutableArray[DeclarationSymbol]]
    {
      mutable hashSet;

      foreach (p in parameters)
      {
        unless (p.IsCustomAttributesEvaluated)
          return VNone();

        when (p.CustomAttributes.Any(_ is PredefinedAttributes.DashboardVisibleSymbol))
        {
          when (hashSet == null)
            hashSet = HashSet();

          _ = hashSet.Add(p);
        }
      }

      when (baseSymbols != null)
      {
        foreach (d in baseSymbols)
        {
          match (getDashboardVisisbleSymbols(d))
          {
            | VNone => return VNone()
            | VSome(additionalParameters) when additionalParameters.IsDefaultOrEmpty => ()
            | VSome(additionalParameters) =>
              when (hashSet == null)
                hashSet = HashSet();

              hashSet.UnionWith(additionalParameters);
          }
        }
      }

      VSome(if (hashSet == null) ImmutableArray.Empty else hashSet.ToImmutableArray())
    }

    private ExpandPathRelativeToAst(ast : IAst, path : string) : string
    {
      Path.GetFullPath(Path.Combine(Path.GetDirectoryName(ast.Location.Source.File.FullName), path))
    }

    public ToHashtable[TKey, TElement, T](this immutableArray : ImmutableArray[T], keySelector : Func[T, TKey], elementSelector : Func[T, TElement]) : Hashtable[TKey, TElement]
    {
      ToHashtable(immutableArray, keySelector, elementSelector, EqualityComparer[TKey].Default);
    }

    public ToHashtable[TKey, TElement, T](this immutableArray : ImmutableArray[T], keySelector : Func[T, TKey], elementSelector : Func[T, TElement], comparer : IEqualityComparer[TKey]) : Hashtable[TKey, TElement]
    {
      def result = Hashtable(immutableArray.Length, comparer);
      foreach (v in immutableArray)
          result.Add(keySelector(v), elementSelector(v));

      result
    }

    public GetMembers(expr : Tdl.Expr) : Scope
    {
      | Reference   (Symbol=Product.DefSymbol as p)     => p.Type.Scope
      | Reference   (Symbol=FormalParameterSymbol as p) => p.Type.Scope
      | Reference   (Symbol=ContainerSymbol as cont)
      | MemberAccess(Symbol=ContainerSymbol as cont) => cont.Scope
      | Reference
      | MemberAccess
      | NotSet
      | Error
      | String
      | True
      | False
      | Real
      | Integer
      | List
      | Tuple
      | ObjectInitializer => EmptyScope.Instance
    }

    public ParseInt(context : DependentPropertyEvalContext, text : string) : int
    {
      mutable result;
      unless (int.TryParse(text, out result))
      {
        //str.Error(context, $"Failed to process deployment file path ($(e.GetType())): $(e.Message)");
      }
      result
    }

    public MakeScenarioActions(context : DependentPropertyEvalContext, barrierExpr : DotNet.Expr) : ValueOption[ScenarioAction]
    {
      match (barrierExpr)
      {
        | Expr.SimpleName as n when !n.IsRefEvaluated || !n.Ref.IsSymbolEvaluated => VNone()
        | Expr.SimpleName(Ref=Ref(IsSymbolEvaluated =true, Symbol=symbol)) =>
          if (symbol is BarrierSymbol as b)
            VSome(ScenarioAction.Barrier(barrierExpr.Location, b))
          else
          {
            barrierExpr.Error(context, "Expected barrier.");
            VSome(ScenarioAction.Error(barrierExpr.Location))
          }

        | Expr.Invocation as inv when !inv.IsMethodEvaluated => VNone()
        | Expr.Invocation as inv when inv.Method.Name != "GetOrCreateBarrier" =>
          barrierExpr.Error(context, "Expected call of GetOrCreateBarrier() method or barrier.");
          VSome(ScenarioAction.Error(barrierExpr.Location))
        | Expr.Invocation as inv when inv.Arguments.Count == 2 =>
          def arg2 = inv.Arguments[1] :> Expr.Argument;
          when (!(arg2.Expr is DotNet.Expr.String))
          {
            barrierExpr.Error(context, "Expected string with timeout.");
            return VSome(ScenarioAction.Error(arg2.Location));
          }
          def timeoutStr = ConvertStringLiteralOrNull((arg2.Expr :> DotNet.Expr.String).Value);
          mutable timeout;
          when (timeoutStr == null || !TimeSpan.TryParse(timeoutStr, out timeout))
          {
            barrierExpr.Error(context, "Expected string with timeout. Format: hh:mm:ss");
            return VSome(ScenarioAction.Error(arg2.Location));
          }
          def arg1 = inv.Arguments[0] :> Expr.Argument;
          if (arg1.Expr is Expr.Sum as sum)
          {
            mutable hasUncalculated;
            {
              def result = ImmutableArray.CreateBuilder();
              def loop(expr : DotNet.Expr) : void
              {
                | Expr.Sum           as sum => loop(sum.Expr1); loop(sum.Expr2);
                | DotNet.Expr.String as s   => result.Add(BarrierNamePart.String(ConvertStringLiteralOrNull(s.Value)));
                | Expr.SimpleName    as n when !n.IsRefEvaluated || !n.Ref.IsSymbolEvaluated => hasUncalculated = true;
                | Expr.SimpleName    as n   => result.Add(BarrierNamePart.Reference(n.Ref.Symbol));
                | _ =>
                  barrierExpr.Error(context, "Unsupported expression type " + expr.GetType().Name);
                  hasUncalculated = true;
              }
              loop(sum);
              if (hasUncalculated)
                VNone()
              else
                VSome(ScenarioAction.BarrierGenerator(barrierExpr.Location, result.ToImmutable(), timeout))
            }
          }
          else
          {
            _ = arg2;
            arg1.Error(context, "Expected concatination of barrier name.");
            VSome(ScenarioAction.Error(arg1.Location))
          }

        | _ => assert2(false); VNone()
      }

      //ScenarioAction.Barrier(BarrierExpr.Location, null)
    }

    private GetCaseInsensitiveId(symbol : DeclarationSymbol) : int
    {
      StringIndex.GetCaseInsensitivePart(symbol.NameId)
    }

    public MakeSuitePlatform(this context : DependentPropertyEvalContext, name : IAst, platformSymbolOpt : ValueOption[PlatformSymbol], baseSuiteOpt : ValueOption[Suite.DefSymbol]) : ValueOption[PlatformSymbol]
    {
      match (platformSymbolOpt, baseSuiteOpt)
      {
        | (VSome(platform), _)                                            => VSome(platform)
        | (VNone(), VSome(baseSuite)) when !baseSuite.IsPlatformEvaluated => VNone()
        | (VNone(), VSome(baseSuite))                                     => VSome(baseSuite.Platform)
        | (VNone(), VNone())                                              => name.Error(context, "The platform must be specified.", 0); def p = Platform.DefSymbol(); p.EvalProperties(context); VSome(p)
        | _                                                               => VNone()
      }
    }

    public MakeSuiteProduct(this context : DependentPropertyEvalContext, name : IAst, productSymbolOpt : ValueOption[ProductSymbol], baseSuiteOpt : ValueOption[Suite.DefSymbol]) : ValueOption[ProductSymbol]
    {
      match (productSymbolOpt, baseSuiteOpt)
      {
        | (VSome(product), _)                                            => VSome(product)
        | (VNone(), VSome(baseSuite)) when !baseSuite.IsProductEvaluated => VNone()
        | (VNone(), VSome(baseSuite))                                    => VSome(baseSuite.Product)
        | (VNone(), VNone())                                             => name.Error(context, "The product must be specified.", 0); def p = Product.DefSymbol(); p.EvalProperties(context); VSome(p)
        | _                                                              => VNone()
      }
    }

    public ResolveSuiteTypeSymbol(this context : DependentPropertyEvalContext, typeAst : IAst, typeRef : Ref[DeclarationSymbol]) : ValueOption[SuiteTypeSymbol]
    {
      def makeDefaulteSuiteTypeSymbol()
      {
        def symbol = SuiteTypeSymbol();
        symbol.EvalProperties(context);
        VSome(symbol)
      }

      if (typeRef == null)
        makeDefaulteSuiteTypeSymbol()
      else
      {
          def bindResult = typeRef.Result.Filter.[Suite.DefSymbol](null);
          if (bindResult.HasResult)
          {
            def result = typeRef.CreateRevole(bindResult);
            if (result.IsAmbiguous)
            {
              typeAst.Error(context, "Suite is ambiguous.", 0);
              makeDefaulteSuiteTypeSymbol()
            }
            else
            {
              if (result.Symbol.IsTypeEvaluated)
                VSome(result.Symbol.Type :> SuiteTypeSymbol)
              else
                VNone()
            }
          }
          else
          {
            def result = typeRef.Resolve();
            if (result.IsUnresolved || result.IsAmbiguous)
              makeDefaulteSuiteTypeSymbol()
            else
              VSome(result.Symbol)
          }
      }
    }

    public MakeBaseSuite(this context : DependentPropertyEvalContext, typeRefOpt : ValueOption[Ref[DeclarationSymbol]]) : ValueOption[ValueOption[Ref[Suite.DefSymbol]]]
    {
      match (typeRefOpt)
      {
        | VSome(r) =>
          def bindResult = r.Result.Filter.[Suite.DefSymbol](null);
          if (bindResult.HasResult)
          {
            def result = r.CreateRevole(bindResult);
            VSome(VSome(result))
          }
          else
            VSome(VNone())

        | VNone() => VSome(VNone())
      }
    }

    public MakeSuiteType(this context : DependentPropertyEvalContext, typeRefOpt : ValueOption[Ref[DeclarationSymbol]], baseSuiteRefOpt : ValueOption[Ref[Suite.DefSymbol]]) : ValueOption[TypeSymbol]
    {
      def makeDefaulteSuiteTypeSymbol()
      {
        def symbol = SuiteTypeSymbol();
        symbol.EvalProperties(context);
        VSome(symbol)
      }

      match (baseSuiteRefOpt)
      {
        | VSome(r) =>
          if (r.IsSymbolEvaluated && r.Symbol.IsTypeEvaluated)
            VSome(r.Symbol.Type)
          else
            VNone()

        | VNone() =>
          match (typeRefOpt)
          {
            | VSome(r) =>
              def result = r.Resolve();
              if (result.IsUnresolved || result.IsAmbiguous)
                makeDefaulteSuiteTypeSymbol()
              else
                VSome(result.Symbol)

            | VNone() => makeDefaulteSuiteTypeSymbol()
          }
      }
    }

    public MakeStatements(statements : ImmutableArray[SuiteStatement], baseSuiteOpt : ValueOption[Suite.DefSymbol]) : ValueOption[ImmutableArray[SuiteStatement]]
    {
      match (baseSuiteOpt)
      {
        | VSome(baseSuite) when !baseSuite.IsStatementsEvaluated => VNone()
        | VSome(baseSuite) => VSome(baseSuite.Statements)
        | VNone() => VSome(statements)
      }
    }
  } // module
} // namespace
