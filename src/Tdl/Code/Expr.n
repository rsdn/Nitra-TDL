using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Declarations;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace Tdl
{
  public variant Expr
  {
    | Error        { Location : Nitra.Location; }
    | String       { Value : string; }
    | True         { }
    | False        { }
    | Real         { Value : double; }
    | Integer      { Value : int; }
    | Reference    { Symbol : DeclarationSymbol; }
    | MemberAccess { Expr : Expr;  Symbol : DeclarationSymbol; Type : TypeSymbol; }
    | List         { Elems : ImmutableArray[Expr]; Type : TypeSymbol; }
    | Tuple        { Elems : ImmutableArray[Expr]; Type : TypeSymbol; }

    public GetExprListForVar(varIndex : int) : Seq[Expr]
    {
      def it = this;
      match (it)
      {
        | Reference(Symbol=Product.SetSymbol    as s) when varIndex == 0 => s.AllProducts   .Select(Expr.Reference)
        | Reference(Symbol=Platform.SetSymbol   as s) when varIndex == 0 => s.Platforms     .Select(Expr.Reference)
        | Reference(Symbol=Deployment.SetSymbol as s) when varIndex == 0 => s.AllDeployments.Select(Expr.Reference)
        | List as list =>
          def getElem(e : Expr) : Expr
          {
            | Reference as r => r
            | Tuple as t => t.Elems[varIndex]
            | _ => e
          }
          list.Elems.Select(getElem)
        | _ => assert(false, $"Unsupporten expressoin type $(GetType().FullName)")
      }
    }

    public GetExprList() : Seq[Expr]
    {
      match (this)
      {
        | Reference(Symbol=Product.SetSymbol    as s) => s.AllProducts   .Select(Expr.Reference)
        | Reference(Symbol=Platform.SetSymbol   as s) => s.Platforms     .Select(Expr.Reference)
        | Reference(Symbol=Deployment.SetSymbol as s) => s.AllDeployments.Select(Expr.Reference)
        | List as list                                => list.Elems
        | _ => assert(false, $"Unsupporten expressoin type $(GetType().FullName)")
      }
    }

    public GetValue() : object
    {
      match (this)
      {
        | True         => true
        | False        => false
        | String  as x => x.Value
        | Real    as x => x.Value
        | Integer as x => x.Value
        | _ => assert(false, $"Non value extression $(GetType().FullName)");
      }
    }
    
    //public GetAllSymbols() : Seq[TypedDeclarationSymbol]
    //{
    //  def result = List();
    //  def scan(e : Expr) : void
    //  {
    //    | Error              => ()
    //    | String             => ()
    //    | True               => ()
    //    | False              => ()
    //    | Real               => ()
    //    | Integer            => ()
    //    | Reference    as x  => result.Add(x.Symbol);
    //    | MemberAccess as x  => scan(x.Expr)
    //    | List         as xs => foreach (e in xs.Elems) scan(e);
    //    | Tuple        as xs => foreach (e in xs.Elems) scan(e);
    //  }
    //
    //  scan(this);
    //  result
    //}

    public override ToString() : string
    {
      match (this)
      {
        | Error              => "<Error>"
        | String(value)      => "@\"" + value.Replace(@"\", @"\\").Replace("\"", @"\""") + '"'
        | True               => "true"
        | False              => "false"
        | Real          as x => x.Value.ToString()
        | Integer       as x => x.Value.ToString()
        | Reference     as x => x.Symbol.InitialName
        | MemberAccess as x  => $"$(x.Expr).$(x.Symbol.Name)"
        | List         as xs => def elems = xs.Elems.Select(_.ToString());  $<#[..$elems]#>
        | Tuple        as x  => def elems =  x.Elems.Select(_.ToString());  $<#(..$elems)#>
      }
    }
  }
}
