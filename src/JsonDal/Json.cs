// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var root = Root.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Linq;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using JsonDal;

    /// <summary>
    /// Объект конфигурации
    /// </summary>
    public partial class Root
    {
        /// <summary>
        /// Номер версии Starter/Warden, с которыми совместим конфиг
        /// </summary>
        [JsonProperty("version")]
        public long Version { get; set; }

        /// <summary>
        /// Добавляет в конфигурацию объекты из других конфигов
        /// </summary>
        [JsonProperty("$include", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Include { get; set; }

        [JsonProperty("$schema", NullValueHandling = NullValueHandling.Ignore)]
        public string Schema { get; set; }

        /// <summary>
        /// Дефолтные значения параметров для всего конфига
        /// </summary>
        [JsonProperty("DefaultValues", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> DefaultValues { get; set; }

        /// <summary>
        /// Описания деплоев
        /// </summary>
        [JsonProperty("Deployments", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, Deployment> Deployments { get; set; }

        /// <summary>
        /// Значения параметров
        /// </summary>
        [JsonProperty("Parameters", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, string> Parameters { get; set; }

        /// <summary>
        /// Описания платформ
        /// </summary>
        [JsonProperty("Platforms", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, PlatformValue> Platforms { get; set; }

        /// <summary>
        /// Описания продуктов
        /// </summary>
        [JsonProperty("Products", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, ProductValue> Products { get; set; }

        /// <summary>
        /// Описания тестов и групп
        /// </summary>
        [JsonProperty("Suites", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, TestSuite> Suites { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, SuiteGroup> SuiteGroups { get; set; }

        /// <summary>
        /// Описания тестов и групп
        /// </summary>
        [JsonProperty("TestScenarios", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, TestCase> TestScenarios { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, TestEntity> TestEntities { get; set; }

        [JsonProperty(Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, SessionActionBase> PreSessionActions { get; set; }

        [JsonProperty(Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, SessionActionBase> PostSessionActions { get; set; }
    }

    /// <summary>
    /// Описание одного шага для подготовки тестового окружения. Может выполнять простые действия
    /// или вызывать другие шаги с определенными переменными
    /// </summary>
    public class Deployment
    {
        /// <summary>
        /// Выбор деплоя в зависимости от значения параметра
        ///
        /// Последовательность деплоев (для тестов compatibility)
        /// </summary>
        [JsonProperty("Type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("RebootExitCode", NullValueHandling = NullValueHandling.Ignore)]
        public int? RebootExitCode { get; set; }

        [JsonProperty("ReturnValue", NullValueHandling = NullValueHandling.Ignore)]
        public int? ReturnValue { get; set; }

        [JsonProperty("ScriptArgs", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> ScriptArgs { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> DefaultValues { get; set; }

        [JsonProperty("ScriptPath", NullValueHandling = NullValueHandling.Ignore)]
        public string ScriptPath { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public byte[] ScriptData { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public string ScriptDataExtension { get; set; }

        [JsonProperty("Timeout", NullValueHandling = NullValueHandling.Ignore)]
        public string Timeout { get; set; }

        [JsonProperty("RebootTimeout", NullValueHandling = NullValueHandling.Ignore)]
        public string RebootTimeout { get; set; }

        /// <summary>
        /// Должен ли выполняться тест, если значения параметра нет в списке? (для хотфиксов)
        /// </summary>
        [JsonProperty("SkipInvalidCondition", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SkipInvalidCondition { get; set; }

        #region Type = Select

        [JsonProperty("Condition", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Condition { get; set; }

        [JsonProperty("Values", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, TestGroupDeployment> Values { get; set; }

        [JsonProperty("Default", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TestGroupDeployment Default { get; set; }

        #endregion

        [JsonProperty("Deployments", NullValueHandling = NullValueHandling.Ignore)]
        public TestGroupDeployment[] Deployments { get; set; }
    }

    /// <summary>
    /// Описание конкретной версии ОС
    /// </summary>
    public partial class Platform
    {
    }

    /// <summary>
    /// Описание версии продукта
    /// </summary>
    public partial class Product
    {
        [JsonProperty("Name")]
        public string Name { get; set; }

        /// <summary>
        /// Определения переменных, которые могут быть использованы в общих деплоях. Например, путь к
        /// инсталлятору и скрипту установки для деплоя 'Install Product'
        /// </summary>
        [JsonProperty("Parameters", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> Parameters { get; set; }

        [JsonProperty("BranchName")]
        public string BranchName { get; set; }

        [JsonProperty("Version", NullValueHandling = NullValueHandling.Ignore)]
        public string Version { get; set; }

        [JsonProperty("DumpServerProduct", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string DumpServerProduct { get; set; }

        [JsonProperty("SupportedPlatforms", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Platforms { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> Capabilities { get; set; }
    }

    /// <summary>
    /// Набор тестов, который можно запустить. Вычисляется декартово произведение {Platform} X
    /// {Product} Х {TestGroup}. Если тест или его деплой не поддерживают продукт и/или платформу
    /// то такие тесты будут пропущены с результатом Skipped. AdditionalDeployments выполняются
    /// перед всеми тестами
    /// </summary>
    public class TestSuite
    {
        [JsonProperty("Parameters", NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> Parameters { get; set; }

        [JsonProperty("Platforms")]
        public string[] Platforms { get; set; }

        [JsonProperty("Products")]
        public string[] Products { get; set; }

        [JsonProperty("TestScenarios")]
        public string[] TestScenarios { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public string TestEntity { get; set; }

        [JsonProperty(Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<string> DashboardVisibleParameters { get; set; }

        [JsonProperty(Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string PreSessionAction { get; set; }

        [JsonProperty(Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string PostSessionAction { get; set; }
    }

    public partial class TestGroup
    {
        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public string FilterExpression { get; set; }

        [JsonProperty("TestScenarios", NullValueHandling = NullValueHandling.Ignore)]
        public string[] TestScenarios { get; set; }

        [JsonProperty("Area", NullValueHandling = NullValueHandling.Ignore)]
        public string Area { get; set; }

        /// <summary>
        /// Необходимые тесту деплои. Будут выполнены в указанном порядке
        /// </summary>
        [JsonProperty("Deployments", NullValueHandling = NullValueHandling.Ignore)]
        public TestGroupDeployment[] Deployments { get; set; }

        /// <summary>
        /// Сочетания {продукты} x {платформы}, для которых поддерживается тест. Например, kes11 на
        /// серверах.
        /// </summary>
        [JsonProperty("Environments", NullValueHandling = NullValueHandling.Ignore)]
        public EnvironmentElement[] Environments { get; set; }

        /// <summary>
        /// Если true, то виндовый агент ставиться не будет
        /// </summary>
        [JsonProperty("NeedPythonAgent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedPythonAgent { get; set; }

        /// <summary>
        /// Аналог параметра сессии/деплоев unsignedAgent в Hive, отвечающий за то, нужен ли
        /// неподписанный агент для выполнения теста
        /// </summary>
        [JsonProperty("NeedUnsignedAgent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedUnsignedAgent { get; set; }

        /// <summary>
        /// Аналог WaitForNetwork - флаг, нужно ли тесту сначала дождаться установления соединения с
        /// интернетом
        /// </summary>
        [JsonProperty("RequireInternet", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RequireInternet { get; set; }

        /// <summary>
        /// Сколько раз перезапускать красный тест
        /// </summary>
        [JsonProperty("RerunCountOnTestFailure", NullValueHandling = NullValueHandling.Ignore)]
        public long? RerunCountOnTestFailure { get; set; }

        [JsonProperty("ExternalAutotestId", NullValueHandling = NullValueHandling.Ignore)]
        public int? ExternalAutotestId { get; set; }

        /// <summary>
        /// Сколько раз перезапускать зеленый тест
        /// </summary>
        [JsonProperty("RerunCountOnTestSuccess", NullValueHandling = NullValueHandling.Ignore)]
        public long? RerunCountOnTestSuccess { get; set; }

        [JsonProperty("Responsible", NullValueHandling = NullValueHandling.Ignore)]
        public string Responsible { get; set; }

        [JsonProperty("RevertAgentAfter", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RevertAgentAfter { get; set; }

        [JsonProperty("RevertAgentBefore", NullValueHandling = NullValueHandling.Ignore)]
        public bool? RevertAgentBefore { get; set; }

        [JsonProperty("TestMethod", NullValueHandling = NullValueHandling.Ignore)]
        public TestMethod TestMethod { get; set; }

        [JsonProperty("TfsId", NullValueHandling = NullValueHandling.Ignore)]
        public long? TfsId { get; set; }

        /// <summary>
        /// Таймаут выполнения теста
        /// </summary>
        [JsonProperty("Timeout", NullValueHandling = NullValueHandling.Ignore)]
        public string Timeout { get; set; }

        [JsonProperty("UniqueId", NullValueHandling = NullValueHandling.Ignore)]
        public Guid? UniqueId { get; set; }

        [JsonProperty("MultiMachineId", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Guid? MultiMachineId { get; set; }

        [JsonProperty("ProductGroupName", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string ProductGroupName { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public string LocalTestBinariesFolder { get; set; }

        [JsonProperty(NullValueHandling = NullValueHandling.Ignore)]
        public IDictionary<string, object> Capabilities { get; set; }
    }

    public partial class EnvironmentElement
    {
        /// <summary>
        /// Список платформ (название отдельной платформы или заготовленного списка)
        /// </summary>
        [JsonProperty("Platforms")]
        public string[] Platforms { get; set; }

        /// <summary>
        /// Список продуктов (название отдельного продукта или заготовленного списка)
        /// </summary>
        [JsonProperty("Products")]
        public string[] Products { get; set; }
    }

    public partial class TestMethodEnvironment
    {
        [JsonProperty("additionalProperties", NullValueHandling = NullValueHandling.Ignore)]
        public string AdditionalProperties { get; set; }
    }


    /// <summary>
    /// Выбор деплоя в зависимости от значения параметра
    ///
    /// Последовательность деплоев (для тестов compatibility)
    /// </summary>
    [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    public enum TypeEnum { Script, Select, Sequence, Reboot, Empty };

    public partial struct PlatformValue
    {
        public Platform Platform;
        public string[] StringArray;

        public static implicit operator PlatformValue(Platform Platform) => new PlatformValue { Platform = Platform };
        public static implicit operator PlatformValue(string[] StringArray) => new PlatformValue { StringArray = StringArray };
    }

    public partial struct ProductValue
    {
        public Product Product;
        public string[] StringArray;

        public static implicit operator ProductValue(Product Product) => new ProductValue { Product = Product };
        public static implicit operator ProductValue(string[] StringArray) => new ProductValue { StringArray = StringArray };
    }

    public partial class TestGroupDeployment : IEquatable<TestGroupDeployment>
    {
        public string DeploymentName;
        public IDictionary<string, object> Parameters;

        public override bool Equals(object obj) => Equals(obj as TestGroupDeployment);

        public bool Equals(TestGroupDeployment other)
        {
            if (other == null || !string.Equals(DeploymentName, other.DeploymentName))
                return false;

            return Parameters.DictionaryEquals(other.Parameters, StringComparison.InvariantCultureIgnoreCase);
        }

        public override int GetHashCode()
        {
            var hashCode = -1920629986;
            var ordinalIgnoreCase = StringComparer.OrdinalIgnoreCase;
            hashCode = hashCode * -1521134295 + ordinalIgnoreCase.GetHashCode(DeploymentName);

            if (Parameters == null)
                return hashCode;

            foreach (var (name, value) in Parameters)
            {
                hashCode = hashCode * -1521134295 + ordinalIgnoreCase.GetHashCode(name);

                if (value != null)
                    hashCode = hashCode * -1521134295 + value.GetHashCode();
            }

            return hashCode;
        }

        public override string ToString()
        {
            return $"{DeploymentName}({string.Join(", ", Parameters?.Select(kvp => kvp.Key + ": " + kvp.Value) ?? Enumerable.Empty<string>())})";
        }

        public static bool operator ==(TestGroupDeployment deployment1, TestGroupDeployment deployment2)
        {
            return EqualityComparer<TestGroupDeployment>.Default.Equals(deployment1, deployment2);
        }

        public static bool operator !=(TestGroupDeployment deployment1, TestGroupDeployment deployment2)
        {
            return !(deployment1 == deployment2);
        }
    }

    public partial struct TestCase
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;
        public TestGroup TestGroup;

        public static implicit operator TestCase(object[] AnythingArray) => new TestCase { AnythingArray = AnythingArray };
        public static implicit operator TestCase(bool Bool) => new TestCase { Bool = Bool };
        public static implicit operator TestCase(double Double) => new TestCase { Double = Double };
        public static implicit operator TestCase(long Integer) => new TestCase { Integer = Integer };
        public static implicit operator TestCase(string String) => new TestCase { String = String };
        public static implicit operator TestCase(TestGroup TestGroup) => new TestCase { TestGroup = TestGroup };
        public bool IsNull => AnythingArray == null && Bool == null && TestGroup == null && Double == null && Integer == null && String == null;
    }

    public partial class Root
    {
        public static Root FromJson(string json) => JsonConvert.DeserializeObject<Root>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Root self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                PlatformValueConverter.Singleton,
                ProductValueConverter.Singleton,
                TestCaseConverter.Singleton,
                TestGroupDeploymentConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PlatformValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PlatformValue) || t == typeof(PlatformValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Platform>(reader);
                    return new PlatformValue { Platform = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new PlatformValue { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type PlatformValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PlatformValue)untypedValue;
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.Platform != null)
            {
                serializer.Serialize(writer, value.Platform);
                return;
            }
            throw new Exception("Cannot marshal type PlatformValue");
        }

        public static readonly PlatformValueConverter Singleton = new PlatformValueConverter();
    }

    internal class ProductValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ProductValue) || t == typeof(ProductValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Product>(reader);
                    return new ProductValue { Product = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new ProductValue { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ProductValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ProductValue)untypedValue;
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.Product != null)
            {
                serializer.Serialize(writer, value.Product);
                return;
            }
            throw new Exception("Cannot marshal type ProductValue");
        }

        public static readonly ProductValueConverter Singleton = new ProductValueConverter();
    }

    internal class TestCaseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TestCase) || t == typeof(TestCase?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new TestCase { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new TestCase { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new TestCase { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new TestCase { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new TestCase { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<TestGroup>(reader);
                    return new TestCase { TestGroup = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new TestCase { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TestCase");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TestCase)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.TestGroup != null)
            {
                serializer.Serialize(writer, value.TestGroup);
                return;
            }
            throw new Exception("Cannot marshal type TestCase");
        }

        public static readonly TestCaseConverter Singleton = new TestCaseConverter();
    }

    internal class TestGroupDeploymentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TestGroupDeployment);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new TestGroupDeployment { DeploymentName = stringValue };
                case JsonToken.StartObject:
                    var x = serializer.Deserialize<Dictionary<string, Dictionary<string, object>>>(reader).Single();
                    return new TestGroupDeployment { DeploymentName = x.Key, Parameters = x.Value };
            }
            throw new Exception("Cannot unmarshal type TestGroupDeployment");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TestGroupDeployment)untypedValue;

            if ((value.Parameters?.Count ?? 0) > 0)
            {
                writer.WriteStartObject();
                writer.WritePropertyName(value.DeploymentName); ;
                serializer.Serialize(writer, value.Parameters);
                writer.WriteEndObject();
            }
            else
            {
                writer.WriteValue(value.DeploymentName);
            }
        }

        public static readonly TestGroupDeploymentConverter Singleton = new TestGroupDeploymentConverter();
    }
}
